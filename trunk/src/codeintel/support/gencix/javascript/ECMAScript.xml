<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<?xml-stylesheet type="text/xsl" href="bflib.xsl"?>
<ref name="ECMAScript" description="ECMAScript" version="2">
  <group name="Global">
    <note title="overview">The global object For official information please see http://msdn.microsoft.com/library/en-us/script56/html/js56jsobjglobal.asp.</note>
    <element kind="var" name="Global_Infinity">
      <note title="overview">The static value "Infinity" Property Type: Infinity</note>
      <properties>
        <property kind="example">
          <description>
            <![CDATA[ This property of the Global object is accessible directly, and is the result value of various mathematical operations. This is also the value of the class property Number.POSITIVE_INFINITY.

var result = 1/0;
var isInfinite = (result == Infinity); // true
var equals = (Infinity == Number.POSITIVE_INFINITY); //true
]]>
</description>
        </property>
      </properties>
      <insert>Infinity</insert>
    </element>
    <element kind="var" name="Global_NaN">
      <note title="overview">Not a Number Property Type: NaN</note>
      <properties>
        <property kind="example">
          <description>
            <![CDATA[ This property of the Global object is accessible directly, and is the result value of various (usually failed) mathematical operations. This is also the value of the class property Number.NaN. However, comparison to NaN always returns false. (Even NaN==NaN evaluates to false.) To see if a value is NaN, use the global isNaN() function.var result = 1 * 'cat' - 'orange';
var isNotANumber = isNaN(result);  //true
var theSame = (result == NaN);     //false; result is NaN, but comparing it to NaN fails
var theSame = (NaN == Number.NaN); //false; Number.NaN is NaN, but comparing it to NaN fails
]]>
</description>
        </property>
      </properties>
      <insert>NaN</insert>
    </element>
    <element kind="var" name="Global_undefined">
      <note title="overview">The static value "undefined" Property Type: undefined</note>
      <properties>
        <property kind="example">
          <description>
            <![CDATA[ Here are some examples where undefined exists in the language:


Variables which have been declared but never initialized:var foo;
var neverInitialized = (foo==undefined); //true

Parameters of functions/methods which are declared but not passed when invoked:function DoSomething(a){
    return (a==undefined); //will be true if no parameter is passed to the function
}

Properties of objects (including indexes of arrays) which have never been set:var person = { name:'Bob', age:40 };
var cats = [ 'Burmese', 'Himalayan', 'Tonkinese', 'Siamese' ];
var doesNotExist = (person.antennaLength==undefined); //true
doesNotExist = (cats[900]==undefined); //true

The return value of functions which do not specify a return value:function DoSomething(){
    var x=12;
    return;
}
var y = DoSomething();
var noReturnValue = (y==undefined); //true


As a property of the Global object, the undefined value should be available for comparison. However, some ECMAScript interpretters (such as that used by IE for MacOS) do not include it. An alternative way to compare for undefined (as opposed to null) is to use typeof:

var foo;
if (typeof(foo)=='undefined'){
    // this code will execute; typeof(undefined) is the string 'undefined'
}
]]>
</description>
        </property>
      </properties>
      <insert>undefined</insert>
    </element>
    <element kind="function" name="Global_eval()">
      <note title="overview">Evaluate the supplied string as ECMAScript code.</note>
      <insert>eval(%_)</insert>
      <properties>
        <property kind="parameter" name="str">
          <description>String The string to evaluate.</description>
        </property>
        <property kind="example">
          <description>
            <![CDATA[ This global function takes arbitrary code in a single string and evaluates it as ECMAScript code. The evaluated code has the same context as the call to the eval() function.

var person = { name:'Billy' , age:13 };
var objAsString = "{ name:'Billy' , age:13 }";
eval("var anotherPerson = "+objAsString);
// ** person and anotherPerson are identical (but separate) objects


Note: This is one of the most abused functions, and is hardly ever appropriate. The above sample simulates one case where it is useful: using ECMAScript object notation (also called JavaScript Object Notation) to pass data between contexts, and then using eval() to turn the string into a full-fledged object.

Another case where eval() is appropriate is when a user's input will be used for code, such as a mathematical expression like "17*x-8".

It is not appropriate (or necessary) to use eval() to build variable names on the fly. To look up a global variable or function by name, for example, use a reference to the Global object (which is 'window' in web browsers) and look up the variable as a property of that object using the square bracket notation. For example:

var p1 = "something";
var i=1;
var theValue = window['p'+i];
// ** the above assumes an object named 'window' which refers to the Global object,
// ** which is true in web browsers but which is not part of the ECMAScript specification
]]>
</description>
        </property>
      </properties>
    </element>
    <element kind="function" name="Global_isFinite()">
      <note title="overview">Returns false if the supplied number is NaN, Infinity or -Infinity; returns true otherwise. Return Type: Boolean</note>
      <insert>isFinite(%_)</insert>
      <properties>
        <property kind="parameter" name="num">
          <description>Number The number to check.</description>
        </property>
        <property kind="example">
          <description>
            <![CDATA[ 
]]>
</description>
        </property>
      </properties>
    </element>
    <element kind="function" name="Global_isNaN()">
      <note title="overview">Returns true if the supplied number is NaN, false otherwise. Return Type: Boolean</note>
      <insert>isNaN(%_)</insert>
      <properties>
        <property kind="parameter" name="num">
          <description>Number The number to check.</description>
        </property>
        <property kind="example">
          <description>
            <![CDATA[ The global function checks if a number object is a valid number (including Infinity and -Infinity instead of NaN (the value given to results which are Not a Number). Although the global NaN value exists, comparisons to it will never evaluate to true...even when compared to itself! To test if a value is NaN, use this function.

var result = 12 * 'apple';
if (isNaN(result)){
    //this code will occur; result is NaN
}
if (result==NaN){
    //this code will NOT occur; result is NaN, but cannot be compared to NaN
}
]]>
</description>
        </property>
      </properties>
    </element>
    <element kind="function" name="Global_parseFloat()">
      <note title="overview">Attempt to convert a string into a number. Return Type: Number</note>
      <insert>parseFloat(%_)</insert>
      <properties>
        <property kind="parameter" name="string">
          <description>String The string to convert to a number.</description>
        </property>
        <property kind="example">
          <description>
            <![CDATA[ 
]]>
</description>
        </property>
      </properties>
    </element>
    <element kind="function" name="Global_parseInt()">
      <note title="overview">Attempt to convert a string into an integer number, using the specified base. Return Type: Number</note>
      <insert>parseInt(%_)</insert>
      <properties>
        <property kind="parameter" name="string">
          <description>String The string to convert to a number.</description>
        </property>
        <property kind="parameter" name="radix">
          <description>Number [optional] The base for the conversion.</description>
        </property>
        <property kind="example">
          <description>
            <![CDATA[ In most cases, var strAsNum = myStr*1; or var strAsnum = +myStr; are more appropriate than using var strAsNum = parseInt(myStr,10). (And they're faster, too.)

Although radix is not required, it should not be omitted. This is because when omitted, it takes on one of three values, depending on the string:
<ul style="margin-bottom:1em">The radix starts out at base 10.
If the first character is a '0', it switches to base 8.
If the next character is an 'x', it switches to base 16.
Given the above, parseInt('11') returns 11, while parseInt('011') returns 9. Because of this, you should always specify your desired base (usually 10) when parsing input from a user.

Unlike an implicit (and faster) conversion to a number by multiplying a value by 1 (e.g. var x='17'; x=x*1;), parseInt reads up to the first character which does not fit the specified radix, and ignores the rest. See the following example for the implications of this:

var userInput1 = "$1,000";
var userInput2 = "1,000";
var userInput3 = "     15zzzzz";
var userInput4 = "1.34";

var val1,val2,val3,val4;

val1 = userInput1*1;            //NaN -- bad characters found
val1 = parseInt(userInput1,10); //NaN -- no valid characters found before invalid ones

val2 = userInput2*1;            //NaN -- bad characters found
val2 = parseInt(userInput2,10); //1 -- the user meant "1000", but the script turned it into just "1", stopping at the comma

val3 = userInput3*1;            //NaN -- bad characters found
val3 = parseInt(userInput3,10); //15 -- leading spaces are ignored, and the conversion stops at the first 'z'

val4 = userInput4*1;            //1.34
val4 = parseInt(userInput4,10); //1 -- the conversion stopped when it hit the decimal. See parseFloat

Despite the above, this function has its uses in user interaction, and is the only way to convert a string into a number using a base other than 10.

var x = parseInt('01011',2); //11
var y = parseInt('ff',16);   //255
]]>
</description>
        </property>
      </properties>
    </element>
  </group>
  <group name="Infinity">
    <note title="overview">The static value "Infinity"</note>
  </group>
  <group name="NaN">
    <note title="overview">The static value Not a Number</note>
  </group>
  <group name="Object">
    <note title="overview">A generic object. Inherited by: Array, anark::Asset, anark::Behavior, Boolean, anark::Camera, anark::Collection, anark::Color, anark::Container, Date, Error, Function, anark::Group, anark::Image, anark::Key, anark::Layer, anark::Light, anark::Material, Math, anark::Matrix, anark::Model, anark::Mouse, anark::Music, anark::Node, Number, anark::Player, anark::Presentation, RegExp, anark::Rotation, anark::Scene, anark::Sound, String, anark::TimeContext, anark::Vector, anark::Video, anark::Window</note>
    <element kind="var" name="Object_constructor">
      <note title="overview">A reference to the constructor class for the current object instance. Property Type: Object</note>
      <properties>
        <property kind="example">
          <description>
            <![CDATA[ Checking the constructor property for a custom object is a clean way to see its type. The following code takes objects of most any type and returns a string representation of them, suitable for use in source code. Note how the constructor property is used to check the object type of the parameter.

//For more information on this function, see http://phrogz.net/JS/Object.prototype.toSourceCode.js
Object.prototype.toSourceCode=function(hier,lv,forObj){
    var out,tabs='',idre=/^[a-z_][a-z0-9_]*$/i;
    if (!lv) lv=0;
    if (hier) tabs=Math.pow(10,lv).toString().substr(1).replace(/0/g,"\t");
    if (this.constructor==Array){
        out=(forObj?'':tabs)+'['+(hier?'\n':'');
        for (var i=0,len=this.length;i&amp;lt;len;i++){
            out+=((this[i]!=null)?this[i].toSourceCode(hier,lv+1):'null')
                +(i&amp;lt;(len-1)?',':'')+(hier?'\n':'');
        }
        return out+tabs+']';
    }else if(this.constructor==Object){
        out=(forObj?'':tabs)+'{'+(hier?'\n':'');
        for (var key in this){
            if (key!='toSourceCode'){
                out+=tabs+(hier?'\t':'')
                    +(idre.test(key)?key:("'"+key+"'"))
                    +":"+(this[key]==null?'null':this[key].toSourceCode(hier,lv+1,true))
                    +","+(hier?'\n':'');
            }
        }
        out=out.replace(/,(\n?)$/,'$1');
        return out+tabs+'}';
    }else if(this.constructor==String) return (forObj?'':tabs)+"'"+this+"'";
    else if(this.constructor==Date) return (forObj?'':tabs)+"new Date("+this.valueOf()+")";
    else return (forObj?'':tabs)+this.toString();
}

The constructor property is especially useful for distinguishing arrays from generic objects, since (per the spec) typeof(myArray) returns the string "object". The following example detects if the returned value is an array or not; if it's not, it is turned into a single-element array.

(In HTML, asking for a form element by name returns the element itself if only one named element exists, or returns an array of elements if more than one name exists. It is often convenient to treat both cases with the same code, which expects an array.)

var myForm=document.getElementById('myFormID');
var products = myForm.elements['product'];
if (products.constructor!=Array) products=[products];

The value of the constructor property is not limited to the built-in object types. The following example shows two custom classes, Mammal and Cat, where a method of the class detects the type of the instance.

function Mammal(name){
    this.name=name;
}
Mammal.prototype.toString=function(){
    if (this.constructor==Cat) return "[Cat '"+this.name+"']";
    else return "[Mammal '"+this.name+"']";
}

function Cat(name){
    this.name=name;
}
Cat.prototype=new Mammal;      //inherit from Mammal
Cat.prototype.constructor=Cat; //but keep the correct constructor

var bob = new Mammal('Bob');
var kitty = new Cat('Felix');

bob.toString();   //returns the string "[Mammal 'Bob']"
kitty.toString(); //returns the string "[Cat 'Felix']"
]]>
</description>
        </property>
      </properties>
      <insert>constructor</insert>
    </element>
    <element kind="var" name="Object_prototype">
      <note title="overview">The prototype for a class. Property Type: Object</note>
      <properties>
        <property kind="example">
          <description>
            <![CDATA[ This property is read-only for intrinsic JS classes (e.g. the Date object) but may be re-assigned for user-defined classes.

While the prototype property is 'read-only' for intrinsic classes, it may be used to extend their functionality. For example the following code uses the prototype property of the Number object to extend all numbers to support a custom 'truncate' method:

Number.prototype.trunctate=function(){
        return this>0?Math.floor(this):Math.ceil(this);
}
var x=12.37;
var y=-12.37;

x = x.truncate(); // ** 12
y = y.truncate(); // ** -12

The following code sample shows how to use the prototype property to cause one class to inherit from another:

function Mammal(name){ 
        this.name=name;
        this.offspring=[];
} 
Mammal.prototype.haveABaby=function(){ 
        var newBaby=new this.constructor("Baby "+this.name); //Uses Cat for cats, Mammal for Mammals
        this.offspring.push(newBaby);
        return newBaby;
} 
Mammal.prototype.toString=function(){ 
        return '[Mammal "'+this.name+'"]';
} 


Cat.prototype = new Mammal;          // Here's where the inheritance occurs 
Cat.prototype.constructor=Cat;       // Otherwise instances of Cat would have a constructor of Mammal 
function Cat(name){ 
        this.name=name;
} 
Cat.prototype.toString=function(){ 
        return '[Cat "'+this.name+'"]';
} 

var msg;

var someAnimal = new Mammal('Mr. Biggles');
msg = 'someAnimal is '+someAnimal;         // ** 'someAnimal is [Mammal "Mr. Biggles"]'

var myPet = new Cat('Felix');
msg = 'myPet is '+myPet;                   // ** 'myPet is [Cat "Felix"]' 

myPet.haveABaby();                         // calls a method inherited from Mammal 
msg = myPet.offspring.length;              // ** 1
msg = "First baby is "+myPet.offspring[0]; // ** 'First baby is [Cat "Baby Felix"]'
]]>
</description>
        </property>
      </properties>
      <insert>prototype</insert>
    </element>
    <element kind="function" name="Object_hasOwnProperty()">
      <note title="overview">Determines if the object/instance itself has the named property or method. Return Type: Boolean</note>
      <insert>hasOwnProperty(%_)</insert>
      <properties>
        <property kind="parameter" name="propertyOrMethodName">
          <description>String The name of the property or method to look for in the object.</description>
        </property>
        <property kind="example">
          <description>
            <![CDATA[ This method returns true of the specific object instance or prototype has a property or method with the name specified. The inheritance chain is not searched. The following example illustrates this:
function Person(){ ... }
Person.prototype.breathe=function(){ ... }
var fredAstaire = new Person();
fredAstaire.dance = function(){ ... }

if (Person.prototype.hasOwnProperty('breathe')){
        // this code will execute...the above call will return true
}
if (fredAstaire.hasOwnProperty('breathe')){
        // this code will NOT execute...
        // fredAstaire knows how to 'breathe', but this is an inherited method
}
if (fredAstaire.hasOwnProperty('dance')){
        // this code will execute...the above call will return true
}
if (Person.prototype.hasOwnProperty('dance')){
        // this code will NOT execute...
        // not every Person knows how to dance
}

]]>
</description>
        </property>
      </properties>
    </element>
    <element kind="function" name="Object_isPrototypeOf()">
      <note title="overview">Determines if the calling object prototype is in the inheritance chain for the supplied argument. Return Type: Boolean</note>
      <insert>isPrototypeOf(%_)</insert>
      <properties>
        <property kind="parameter" name="instanceToTest">
          <description>Object The object instance to check.</description>
        </property>
        <property kind="example">
          <description>
            <![CDATA[ The following code sample shows how to use this method to test if an object instance inherits from the calling prototype:
function Mammal(){ ... }
function Human(){ ... }
Human.prototype = new Mammal; //Human inherits from Mammal
var billGates = new Human();
if (Human.isPrototypeOf(billGates)){
        //this code will NOT run...
        //you must call this method on a prototype object
}
if (Human.prototype.isPrototypeOf(billGates)){
        //this code will run...the above will return true
}
if (Mammal.prototype.isPrototypeOf(billGates)){
        //this code will run...the above will return true
}
]]>
</description>
        </property>
      </properties>
    </element>
    <element kind="function" name="Object_propertyIsEnumerable()">
      <note title="overview">Determines if the object/instance itself has a property or method of the supplied name which will appear in a for (prop in obj) enumeration. Return Type: Boolean</note>
      <insert>propertyIsEnumerable(%_)</insert>
      <properties>
        <property kind="parameter" name="propertyOrMethodName">
          <description>String The name of the property or method to look for.</description>
        </property>
        <property kind="example">
          <description>
            <![CDATA[ This method does not search the inheritance chain of any instance supplied. Returns false if no property/method of the supplied name exists, or if one exists but will not appear during enumeration.

In general, built-in properties and methods are not enumerable, while user-defined properties and methods are.
]]>
</description>
        </property>
      </properties>
    </element>
    <element kind="function" name="Object_toLocaleString()">
      <note title="overview">For most objects, the same as toString() unless explicitly overridden. Return Type: String (this method takes no arguments)</note>
      <insert>toLocaleString()</insert>
      <properties>
        <property kind="example">
          <description>
            <![CDATA[ 
]]>
</description>
        </property>
      </properties>
    </element>
    <element kind="function" name="Object_toString()">
      <note title="overview">Returns a string representation of the object. Return Type: String (this method takes no arguments)</note>
      <insert>toString()</insert>
      <properties>
        <property kind="example">
          <description>
            <![CDATA[ For most objects, returns the string "[object "+className+"]". For internal objects, returns the following:ArrayEach member of the array has toString() called on it, and the results are joined together with commas. Equivalent to myArray.join().BooleanReturns "true" for true, "false" for false.DateThe format of the string value returned depends on the implementation. Often a human-readable string such as "Mon Nov 17 2003 13:56:48 GMT-0700"FunctionThe format of the string value returned depends on the implementation. Often a source-code representation of the function.NumberThe number converted to a string value. (See the specific entry for Number.toString(radix).)StringThe string's value.
</elem>]]>
</description>
        </property>
      </properties>
    </element>
    <element kind="function" name="Object_valueOf()">
      <note title="overview">Returns the internal this value of the object. Return Type: String (this method takes no arguments)</note>
      <insert>valueOf()</insert>
      <properties>
        <property kind="example">
          <description>
            <![CDATA[ For various intrinsic JS object types, this value returned is overridden and customized as follows:ArraySame as the Array.toString() method.Boolean(unchanged) The true/false value itself.DateA Number object with an integer value representing the time in milliseconds since Midnight, January 1st, 1970 UTC.Function(unchanged) A reference to the function object itself.Number(unchanged) The number value itself.Object(unchanged) A reference to the object itself.StringThe string's value.
]]>
</description>
        </property>
      </properties>
    </element>
  </group>
  <group name="Array">
    <note title="overview">A sparse array. Inherits from: Object</note>
    <element kind="var" name="Array_constructor">
      <note title="overview">A reference to the constructor class for the current object instance. Property Type: Object</note>
      <properties>
        <property kind="example">
          <description>
            <![CDATA[ Checking the constructor property for a custom object is a clean way to see its type. The following code takes objects of most any type and returns a string representation of them, suitable for use in source code. Note how the constructor property is used to check the object type of the parameter.

//For more information on this function, see http://phrogz.net/JS/Object.prototype.toSourceCode.js
Object.prototype.toSourceCode=function(hier,lv,forObj){
    var out,tabs='',idre=/^[a-z_][a-z0-9_]*$/i;
    if (!lv) lv=0;
    if (hier) tabs=Math.pow(10,lv).toString().substr(1).replace(/0/g,"\t");
    if (this.constructor==Array){
        out=(forObj?'':tabs)+'['+(hier?'\n':'');
        for (var i=0,len=this.length;i&amp;lt;len;i++){
            out+=((this[i]!=null)?this[i].toSourceCode(hier,lv+1):'null')
                +(i&amp;lt;(len-1)?',':'')+(hier?'\n':'');
        }
        return out+tabs+']';
    }else if(this.constructor==Object){
        out=(forObj?'':tabs)+'{'+(hier?'\n':'');
        for (var key in this){
            if (key!='toSourceCode'){
                out+=tabs+(hier?'\t':'')
                    +(idre.test(key)?key:("'"+key+"'"))
                    +":"+(this[key]==null?'null':this[key].toSourceCode(hier,lv+1,true))
                    +","+(hier?'\n':'');
            }
        }
        out=out.replace(/,(\n?)$/,'$1');
        return out+tabs+'}';
    }else if(this.constructor==String) return (forObj?'':tabs)+"'"+this+"'";
    else if(this.constructor==Date) return (forObj?'':tabs)+"new Date("+this.valueOf()+")";
    else return (forObj?'':tabs)+this.toString();
}

The constructor property is especially useful for distinguishing arrays from generic objects, since (per the spec) typeof(myArray) returns the string "object". The following example detects if the returned value is an array or not; if it's not, it is turned into a single-element array.

(In HTML, asking for a form element by name returns the element itself if only one named element exists, or returns an array of elements if more than one name exists. It is often convenient to treat both cases with the same code, which expects an array.)

var myForm=document.getElementById('myFormID');
var products = myForm.elements['product'];
if (products.constructor!=Array) products=[products];

The value of the constructor property is not limited to the built-in object types. The following example shows two custom classes, Mammal and Cat, where a method of the class detects the type of the instance.

function Mammal(name){
    this.name=name;
}
Mammal.prototype.toString=function(){
    if (this.constructor==Cat) return "[Cat '"+this.name+"']";
    else return "[Mammal '"+this.name+"']";
}

function Cat(name){
    this.name=name;
}
Cat.prototype=new Mammal;      //inherit from Mammal
Cat.prototype.constructor=Cat; //but keep the correct constructor

var bob = new Mammal('Bob');
var kitty = new Cat('Felix');

bob.toString();   //returns the string "[Mammal 'Bob']"
kitty.toString(); //returns the string "[Cat 'Felix']"
]]>
</description>
        </property>
      </properties>
      <insert>constructor</insert>
    </element>
    <element kind="var" name="Array_length">
      <note title="overview">The number of items in the array. Property Type: Number</note>
      <properties>
        <property kind="example">
          <description>
            <![CDATA[ This property returns an integer value that is one greater than the largest index in the array. As arrays are sparse, it is mostly a convenience property for iterating over the specified values in an array. Consider the following code:

var foo = [];
// ** foo.length is 0
// ** foo[10] is undefined -- typeof(foo[10])=='undefined'

foo[0]='Hello';
foo[1]='World';
// ** foo.length is now 2

foo.length=10;
foo[6] = "Zebras";
// ** foo.length is now 10
// ** foo[5] is undefined, despite being 'in' the array

foo.length=0;
// ** foo[0] is now undefined, having previously been "Hello"

<p style="margin-bottom:0">In the above, we see that:
<ul style="margin-top:0">
If not previously set, the value of any element in an array is undefined, whether no matter how big or small the length of the array is. (Setting the array to a specific size does not prefill the intermediate indexes with any particular value, including null.)
Assigning a value to an index greater than the current length is legal, and autogrows the array.
Setting the length to a new value is legal. Setting the length to a value smaller than it was previously causes all indexes of greater value to be cleared (set to undefined).


Note that it is almost always (slightly) faster to assign the number of items in an array to a local variable when iterating the array, rather than looking up the length on each iteration:

for (var i=0,len=myArray.length;i&amp;lt;len;i++){ ... }
]]>
</description>
        </property>
      </properties>
      <insert>length</insert>
    </element>
    <element kind="var" name="Array_prototype">
      <note title="overview">The prototype for a class. Property Type: Object</note>
      <properties>
        <property kind="example">
          <description>
            <![CDATA[ This property is read-only for intrinsic JS classes (e.g. the Date object) but may be re-assigned for user-defined classes.

While the prototype property is 'read-only' for intrinsic classes, it may be used to extend their functionality. For example the following code uses the prototype property of the Number object to extend all numbers to support a custom 'truncate' method:

Number.prototype.trunctate=function(){
        return this>0?Math.floor(this):Math.ceil(this);
}
var x=12.37;
var y=-12.37;

x = x.truncate(); // ** 12
y = y.truncate(); // ** -12

The following code sample shows how to use the prototype property to cause one class to inherit from another:

function Mammal(name){ 
        this.name=name;
        this.offspring=[];
} 
Mammal.prototype.haveABaby=function(){ 
        var newBaby=new this.constructor("Baby "+this.name); //Uses Cat for cats, Mammal for Mammals
        this.offspring.push(newBaby);
        return newBaby;
} 
Mammal.prototype.toString=function(){ 
        return '[Mammal "'+this.name+'"]';
} 


Cat.prototype = new Mammal;          // Here's where the inheritance occurs 
Cat.prototype.constructor=Cat;       // Otherwise instances of Cat would have a constructor of Mammal 
function Cat(name){ 
        this.name=name;
} 
Cat.prototype.toString=function(){ 
        return '[Cat "'+this.name+'"]';
} 

var msg;

var someAnimal = new Mammal('Mr. Biggles');
msg = 'someAnimal is '+someAnimal;         // ** 'someAnimal is [Mammal "Mr. Biggles"]'

var myPet = new Cat('Felix');
msg = 'myPet is '+myPet;                   // ** 'myPet is [Cat "Felix"]' 

myPet.haveABaby();                         // calls a method inherited from Mammal 
msg = myPet.offspring.length;              // ** 1
msg = "First baby is "+myPet.offspring[0]; // ** 'First baby is [Cat "Baby Felix"]'
]]>
</description>
        </property>
      </properties>
      <insert>prototype</insert>
    </element>
    <element kind="function" name="Array_concat()">
      <note title="overview">Concatenates one or more items or arrays onto the current array. Return Type: Array</note>
      <insert>concat(%_)</insert>
      <properties>
        <property kind="parameter" name="item1">
          <description>Object [optional] The first item to add.</description>
        </property>
        <property kind="parameter" name="item2">
          <description>Object [optional] The second item to add.</description>
        </property>
        <property kind="parameter" name="...">
          <description>Object [optional] etc.</description>
        </property>
        <property kind="example">
          <description>
            <![CDATA[ This method takes an arbitrary number of parameters, and concatenates the values onto the calling array object. As with most ECMAScript object methods, the calling object is not modified; instead, the result of the operation is returned as a new array.

If no arguments are supplied, a duplicate of the current array is returned. (Not a pointer to the same array.)

If any argument is itself an array, then the contents of that array are added, not the array itself. In other words:
var hisColors = [ 'blue', 'red' ];
var herColors = [ 'purple' , 'pink', 'yellow' ];
var hisAndHers = hisColors.concat(herColors);
    //hisColors is still ['blue','red'];
    //hisAndHers is ['blue','red','purple','pink','yellow']
    //it is NOT ['blue','red',['purple','pink','yellow']

var someColors = hisColors.concat( 'orange' , 'green' , ['black', 'white'] );
someColors.toString(); //blue,red,orange,green,black,white
]]>
</description>
        </property>
      </properties>
    </element>
    <element kind="function" name="Array_hasOwnProperty()">
      <note title="overview">Determines if the object/instance itself has the named property or method. Return Type: Boolean</note>
      <insert>hasOwnProperty(%_)</insert>
      <properties>
        <property kind="parameter" name="propertyOrMethodName">
          <description>String The name of the property or method to look for in the object.</description>
        </property>
        <property kind="example">
          <description>
            <![CDATA[ This method returns true of the specific object instance or prototype has a property or method with the name specified. The inheritance chain is not searched. The following example illustrates this:
function Person(){ ... }
Person.prototype.breathe=function(){ ... }
var fredAstaire = new Person();
fredAstaire.dance = function(){ ... }

if (Person.prototype.hasOwnProperty('breathe')){
        // this code will execute...the above call will return true
}
if (fredAstaire.hasOwnProperty('breathe')){
        // this code will NOT execute...
        // fredAstaire knows how to 'breathe', but this is an inherited method
}
if (fredAstaire.hasOwnProperty('dance')){
        // this code will execute...the above call will return true
}
if (Person.prototype.hasOwnProperty('dance')){
        // this code will NOT execute...
        // not every Person knows how to dance
}

]]>
</description>
        </property>
      </properties>
    </element>
    <element kind="function" name="Array_isPrototypeOf()">
      <note title="overview">Determines if the calling object prototype is in the inheritance chain for the supplied argument. Return Type: Boolean</note>
      <insert>isPrototypeOf(%_)</insert>
      <properties>
        <property kind="parameter" name="instanceToTest">
          <description>Object The object instance to check.</description>
        </property>
        <property kind="example">
          <description>
            <![CDATA[ The following code sample shows how to use this method to test if an object instance inherits from the calling prototype:
function Mammal(){ ... }
function Human(){ ... }
Human.prototype = new Mammal; //Human inherits from Mammal
var billGates = new Human();
if (Human.isPrototypeOf(billGates)){
        //this code will NOT run...
        //you must call this method on a prototype object
}
if (Human.prototype.isPrototypeOf(billGates)){
        //this code will run...the above will return true
}
if (Mammal.prototype.isPrototypeOf(billGates)){
        //this code will run...the above will return true
}
]]>
</description>
        </property>
      </properties>
    </element>
    <element kind="function" name="Array_join()">
      <note title="overview">Returns a string representation of the array, separated by the delimiter of your choice. Return Type: String</note>
      <insert>join(%_)</insert>
      <properties>
        <property kind="parameter" name="separator">
          <description>String [optional] The string to separate each element with.</description>
        </property>
        <property kind="example">
          <description>
            <![CDATA[ Calls the toString() method of each value in the array, and joins them together with the seperator supplied.

If separator is omitted, a single comma "," is used. If you want no separator between the values, specify an empty string "".

var words = [ 'The' , 'quick' , 'brown' , 'fox' ];

//The following statements are all true
words.join()        == "The,quick,brown,fox";
words.join(' ')     == "The quick brown fox";
words.join(' :: ')  == "The :: quick :: brown :: fox";
words.join('')      == "Thequickbrownfox";
]]>
</description>
        </property>
      </properties>
    </element>
    <element kind="function" name="Array_pop()">
      <note title="overview">Remove the last element from the array and return it. Return Type: Object (this method takes no arguments)</note>
      <insert>pop()</insert>
      <properties>
        <property kind="example">
          <description>
            <![CDATA[ This method modifies the array which calls it. 

Along with push(), this method allows arrays to be used as a 'stack' or 'FILO' object. The following code illustrates the push() and pop() methods in use.

var thingsToDo=[];
thingsToDo.push('TheLaundry');
thingsToDo.push('TheDishes');
thingsToDo.push('PlayVideoGames');

thingsToDo.length == 3; //true
thingsToDo.toString() == "TheLaundry,TheDishes,PlayVideoGames"; //true

var mostRecentAddition = thingsToDo.pop();
mostRecentAddition == "PlayVideoGames"; //true

thingsToDo.length == 2; //true--pop() removed the item
thingsToDo.toString() == "TheLaundry,TheDishes"; //true
]]>
</description>
        </property>
      </properties>
    </element>
    <element kind="function" name="Array_propertyIsEnumerable()">
      <note title="overview">Determines if the object/instance itself has a property or method of the supplied name which will appear in a for (prop in obj) enumeration. Return Type: Boolean</note>
      <insert>propertyIsEnumerable(%_)</insert>
      <properties>
        <property kind="parameter" name="propertyOrMethodName">
          <description>String The name of the property or method to look for.</description>
        </property>
        <property kind="example">
          <description>
            <![CDATA[ This method does not search the inheritance chain of any instance supplied. Returns false if no property/method of the supplied name exists, or if one exists but will not appear during enumeration.

In general, built-in properties and methods are not enumerable, while user-defined properties and methods are.
]]>
</description>
        </property>
      </properties>
    </element>
    <element kind="function" name="Array_push()">
      <note title="overview">Adds one or more elements to the end of the array, returning the new length. Return Type: Number</note>
      <insert>push(%_)</insert>
      <properties>
        <property kind="parameter" name="item1">
          <description>Object [optional] The first item to add.</description>
        </property>
        <property kind="parameter" name="item2">
          <description>Object [optional] The second item to add.</description>
        </property>
        <property kind="parameter" name="...">
          <description>Object [optional] etc.</description>
        </property>
        <property kind="example">
          <description>
            <![CDATA[ Unlike Array.concat(), this method modifies the array which calls it. Also unlike that method, any arrays passed as arguments to this method are added as their own item, not as each individual piece.

var colors = [ 'red' , 'green' ];
var more = colors.concat( 'orange' , 'yellow' , [ 'black' , 'white' ] );
var newLength = colors.push( 'orange' , 'yellow' , [ 'black' , 'white' ] );
// ** more is ['red','green','orange','yellow','black','white'];
// ** colors is now ['red','green','orange','yellow',['black','white'];
// ** newLength is 5

Along with pop(), this method allows arrays to be used as a 'stack' or 'FILO' object. The following code illustrates the push() and pop() methods in use.

var thingsToDo=[];
thingsToDo.push('TheLaundry');
thingsToDo.push('TheDishes');
thingsToDo.push('PlayVideoGames');
// ** thingsToDo.length is now 3
// ** thingsToDo is ['TheLaundry','TheDishes','PlayVideoGames']

var mostRecentAddition = thingsToDo.pop();
// ** mostRecentAddition is "PlayVideoGames"
// ** thingsToDo.length is now 2; pop() removed the item
// ** thingsToDo is ['TheLaundry','TheDishes']

Along with shift(), this method allows arrays to be used as a 'queue' or 'FIFO' object. The following code illustrates the push() and shift() methods in use.

var thingsToDo=[];
thingsToDo.push('TheLaundry');
thingsToDo.push('TheDishes');
thingsToDo.push('PlayVideoGames');
// ** thingsToDo is ['TheLaundry','TheDishes','PlayVideoGames']

var firstThingToDo = thingsToDo.shift();
// ** firstThingToDo is "TheLaundry"
// ** thingsToDo.length is now 2; shift() removed the item
// ** thingsToDo is now ['TheDishes','PlayVideoGames']
]]>
</description>
        </property>
      </properties>
    </element>
    <element kind="function" name="Array_reverse()">
      <note title="overview">Reverses the order of the elements in the array, and returns the array. Return Type: Array (this method takes no arguments)</note>
      <insert>reverse()</insert>
      <properties>
        <property kind="example">
          <description>
            <![CDATA[ The original array is modified, and also returned; a new array is not created.

var foo = [0,1,2,3,4];
foo[9]=9;
foo.reverse();
foo.toString()=="9,,,,,4,3,2,1,0";
]]>
</description>
        </property>
      </properties>
    </element>
    <element kind="function" name="Array_shift()">
      <note title="overview">Removes the first element of the array and returns it. Return Type: Object (this method takes no arguments)</note>
      <insert>shift()</insert>
      <properties>
        <property kind="example">
          <description>
            <![CDATA[ Along with push(), this method allows arrays to be used as a 'queue' or 'FIFO' object. The following code illustrates the push() and shift() methods in use.

var thingsToDo=[];
thingsToDo.push('TheLaundry');
thingsToDo.push('TheDishes');
thingsToDo.push('PlayVideoGames');

thingsToDo.length == 3; //true
thingsToDo.toString() == "TheLaundry,TheDishes,PlayVideoGames"; //true

var firstThingToDo = thingsToDo.shift();
firstThingToDo == "TheLaundry"; //true

thingsToDo.length == 2; //true--shift() removed the item
thingsToDo.toString() == "TheDishes, PlayVideoGames"; //true
]]>
</description>
        </property>
      </properties>
    </element>
    <element kind="function" name="Array_slice()">
      <note title="overview">Return a specified section of an array. Return Type: Array</note>
      <insert>slice(%_)</insert>
      <properties>
        <property kind="parameter" name="start">
          <description>Number The index to start copying from.</description>
        </property>
        <property kind="parameter" name="end">
          <description>Number [optional] The index to copy up until.</description>
        </property>
        <property kind="example">
          <description>
            <![CDATA[ A new array is created, and values from the original array are copied into it, starting at the start index and up to (but not including) the end index. If end is omitted, the copying continues from start until the end of the array.If either start or end are negative, they are treated as offsets from the end of the array. For example:var colors = [ 'black' , 'white' , 'orange' , 'green' , 'red' ];
var firstTwo = colors.slice(0,2);   // ['black','white']
var secondPair = colors.slice(2,4);   // ['orange','green']
var lastTwo = colors.slice(-2);   // ['green','red']
var thirdFromTheEnd = colors.slice(-3,-2);   // ['orange']
var allButTheLastTwo = colors.slice(0,-2);   // ['black','white','orange'];If the calculated end point is less than or equal to the calculated start point, an empty array is returned.
]]>
</description>
        </property>
      </properties>
    </element>
    <element kind="function" name="Array_sort()">
      <note title="overview">Sort the array. Return Type: Array</note>
      <insert>sort(%_)</insert>
      <properties>
        <property kind="parameter" name="compareFunction">
          <description>Function [optional] The comparison function to use (see below).</description>
        </property>
        <property kind="example">
          <description>
            <![CDATA[ The original array is sorted (modified), and a reference to the array is returned.

If no comparison function is supplied, toString() is called on each element of the array and a text-based, ascending-order comparison is used. For example:

var animals = [ 'ant' , 'cat' , 'boar' , 'aardvark' , 'elephant' ];
var numbers = [ 1 , 200 , 3 , 5 , 4 , 2 , 13 , 22 ];
animals.sort();   // ['aardvark','ant','boar','cat','elephant']
numbers.sort();   // [1,13,2,200,22,3,4,5]
// *** Numbers are converted to strings and compared as 'words' using the default sort

If a custom comparison function is supplied, it will be supplied two arguments, corresponding to two particular elements in the array to be sorted. The function must return -1 if the first argument should come before the second, 1 if it should come after the second argument, or 0 if the two arguments should be considered the same.

Following are two examples showing how to use a custom comparison function:

var numbers = [ 1 , 200 , 3 , 5 , 4 , 2 , 13 , 22 ];
function compareNumbers(a,b){
    return (a&amp;lt;b)?-1:(a&amp;gt;b)?1:0;

    //the above is the same as:
    //if (a&amp;lt;b) return -1;
    //else if (a&amp;gt;b) return 1;
    //else return 0
}
numbers.sort(compareNumbers);   // [1,2,3,4,5,13,22,200]

var people = [];
people.push( { name:'Bob' , age:15 , sex:'M' } );
people.push( { name:'Carol' , age:18 , sex:'F' } );
people.push( { name:'Sue' , age:33 , sex:'F' } );
people.push( { name:'Angie' , age:8 , sex:'F' } );
people.push( { name:'David' , age:12 , sex:'M' } );

people.sort( function(a,b){ return (a.age&amp;lt;b.age)?-1:(a.age&amp;gt;b.age)?1:0 } );
/************************************************************************
people is now:
[
    { name:'Angie', age:8, sex:'F' },
    { name:'David', age:12, sex:'M' },
    { name:'Bob', age:15, sex:'M' },
    { name:'Carol', age:18, sex:'F' },
    { name:'Sue', age:33, sex:'F' }
]
************************************************************************/

function compareSexThenName(a,b){
    if (a.sex&amp;lt;b.sex) return -1;
    else if (a.sex&amp;gt;b.sex) return 1;
    else return (a.name&amp;lt;b.name)?-1:(a.name&amp;gt;b.name)?1:0;
}
people.sort(compareSexThenName);
/************************************************************************
people is now:
[
    {name:'Angie', age:8, sex:'F'},
    {name:'Carol', age:18, sex:'F'},
    {name:'Sue', age:33, sex:'F'},
    {name:'Bob', age:15, sex:'M'},
    {name:'David', age:12, sex:'M'}
]
************************************************************************/

For a flexible convenience function to generate sorting functions for you, see SortBy.
]]>
</description>
        </property>
      </properties>
    </element>
    <element kind="function" name="Array_splice()">
      <note title="overview">Remove a section from the array and return it; optionally inserting new values in that place. Return Type: Array</note>
      <insert>splice(%_)</insert>
      <properties>
        <property kind="parameter" name="start">
          <description>Number The index to start deleting from.</description>
        </property>
        <property kind="parameter" name="deleteCount">
          <description>Number The number of items to remove.</description>
        </property>
        <property kind="parameter" name="newItem1">
          <description>Object [optional] The first item to insert.</description>
        </property>
        <property kind="parameter" name="newItem2">
          <description>Object [optional] The second item to insert.</description>
        </property>
        <property kind="parameter" name="...">
          <description>Object [optional] etc.</description>
        </property>
        <property kind="example">
          <description>
            <![CDATA[ A new array is created, and deleteCount elements are copied from the start index into the new array. They are also removed from the original array (modifying it).If any additional parameters are present, they are inserted in that location. If any of those parameters are arrays, they are added as a single element. (The array is not traversed to insert each of its elements separately.)As shown in the example below, this method may be used to insert items into an array at a particular location without removing any.var peopleInLine = [ 'Dan' , 'Susan' , 'Emily' ];

//Susan lets someone into the line in front of her!
peopleInLine.splice(1,0,'Mr. Line Cutter'); 
// ** peopleInLine is now ['Dan','Mr. Line Cutter','Susan','Emily']

//Susan and her friend get kicked out of line and replaced by the elderly.
peopleInLine.splice(1,2,'Nice Old Lady','Nice Old Man'); 
// ** peopleInLine is now ['Dan','Nice Old Lady','Nice Old Man','Emily']

//Another line opens, and the first three people in the line go to it
var newLine = peopleInLine.splice(0,3);
// ** newLine is now ['Dan','Nice Old Lady','Nice Old Man']
// ** peopleInLine is now ['Emily']
]]>
</description>
        </property>
      </properties>
    </element>
    <element kind="function" name="Array_toLocaleString()">
      <note title="overview">For most objects, the same as toString() unless explicitly overridden. Return Type: String (this method takes no arguments)</note>
      <insert>toLocaleString()</insert>
      <properties>
        <property kind="example">
          <description>
            <![CDATA[ 
]]>
</description>
        </property>
      </properties>
    </element>
    <element kind="function" name="Array_toString()">
      <note title="overview">Returns a string representation of the object. Return Type: String (this method takes no arguments)</note>
      <insert>toString()</insert>
      <properties>
        <property kind="example">
          <description>
            <![CDATA[ For most objects, returns the string "[object "+className+"]". For internal objects, returns the following:ArrayEach member of the array has toString() called on it, and the results are joined together with commas. Equivalent to myArray.join().BooleanReturns "true" for true, "false" for false.DateThe format of the string value returned depends on the implementation. Often a human-readable string such as "Mon Nov 17 2003 13:56:48 GMT-0700"FunctionThe format of the string value returned depends on the implementation. Often a source-code representation of the function.NumberThe number converted to a string value. (See the specific entry for Number.toString(radix).)StringThe string's value.
</elem>]]>
</description>
        </property>
      </properties>
    </element>
    <element kind="function" name="Array_unshift()">
      <note title="overview">Insert items to the front of an array, and return the new length. Return Type: Number</note>
      <insert>unshift(%_)</insert>
      <properties>
        <property kind="parameter" name="newItem1">
          <description>Object [optional] The first item to insert.</description>
        </property>
        <property kind="parameter" name="newItem2">
          <description>Object [optional] The second item to insert.</description>
        </property>
        <property kind="parameter" name="...">
          <description>Object [optional] etc.</description>
        </property>
        <property kind="example">
          <description>
            <![CDATA[ The original array is modified. If any argument is itself an array, it is added as a single element. (Use Array.concat() to stick two arrays together.) The items added to the array are in the same order as they appear in the arguments list. For example:var peopleInLine = [ 'Bob' , 'Joe' , 'Susan' , 'Lisa' , 'Dan' ];
var lineCount = peopleInLine.unshift('VIP1','VIP2','VIP3','VIP4');
// ** lineCount is 9
// ** peopleInLine is ['VIP1','VIP2','VIP3','VIP4','Bob','Joe','Susan','Lisa','Dan']
]]>
</description>
        </property>
      </properties>
    </element>
    <element kind="function" name="Array_valueOf()">
      <note title="overview">Returns the internal this value of the object. Return Type: String (this method takes no arguments)</note>
      <insert>valueOf()</insert>
      <properties>
        <property kind="example">
          <description>
            <![CDATA[ For various intrinsic JS object types, this value returned is overridden and customized as follows:ArraySame as the Array.toString() method.Boolean(unchanged) The true/false value itself.DateA Number object with an integer value representing the time in milliseconds since Midnight, January 1st, 1970 UTC.Function(unchanged) A reference to the function object itself.Number(unchanged) The number value itself.Object(unchanged) A reference to the object itself.StringThe string's value.
]]>
</description>
        </property>
      </properties>
    </element>
  </group>
  <group name="Boolean">
    <note title="overview">Holds true/false values. Inherits from: Object</note>
    <element kind="var" name="Boolean_constructor">
      <note title="overview">A reference to the constructor class for the current object instance. Property Type: Object</note>
      <properties>
        <property kind="example">
          <description>
            <![CDATA[ Checking the constructor property for a custom object is a clean way to see its type. The following code takes objects of most any type and returns a string representation of them, suitable for use in source code. Note how the constructor property is used to check the object type of the parameter.

//For more information on this function, see http://phrogz.net/JS/Object.prototype.toSourceCode.js
Object.prototype.toSourceCode=function(hier,lv,forObj){
    var out,tabs='',idre=/^[a-z_][a-z0-9_]*$/i;
    if (!lv) lv=0;
    if (hier) tabs=Math.pow(10,lv).toString().substr(1).replace(/0/g,"\t");
    if (this.constructor==Array){
        out=(forObj?'':tabs)+'['+(hier?'\n':'');
        for (var i=0,len=this.length;i&amp;lt;len;i++){
            out+=((this[i]!=null)?this[i].toSourceCode(hier,lv+1):'null')
                +(i&amp;lt;(len-1)?',':'')+(hier?'\n':'');
        }
        return out+tabs+']';
    }else if(this.constructor==Object){
        out=(forObj?'':tabs)+'{'+(hier?'\n':'');
        for (var key in this){
            if (key!='toSourceCode'){
                out+=tabs+(hier?'\t':'')
                    +(idre.test(key)?key:("'"+key+"'"))
                    +":"+(this[key]==null?'null':this[key].toSourceCode(hier,lv+1,true))
                    +","+(hier?'\n':'');
            }
        }
        out=out.replace(/,(\n?)$/,'$1');
        return out+tabs+'}';
    }else if(this.constructor==String) return (forObj?'':tabs)+"'"+this+"'";
    else if(this.constructor==Date) return (forObj?'':tabs)+"new Date("+this.valueOf()+")";
    else return (forObj?'':tabs)+this.toString();
}

The constructor property is especially useful for distinguishing arrays from generic objects, since (per the spec) typeof(myArray) returns the string "object". The following example detects if the returned value is an array or not; if it's not, it is turned into a single-element array.

(In HTML, asking for a form element by name returns the element itself if only one named element exists, or returns an array of elements if more than one name exists. It is often convenient to treat both cases with the same code, which expects an array.)

var myForm=document.getElementById('myFormID');
var products = myForm.elements['product'];
if (products.constructor!=Array) products=[products];

The value of the constructor property is not limited to the built-in object types. The following example shows two custom classes, Mammal and Cat, where a method of the class detects the type of the instance.

function Mammal(name){
    this.name=name;
}
Mammal.prototype.toString=function(){
    if (this.constructor==Cat) return "[Cat '"+this.name+"']";
    else return "[Mammal '"+this.name+"']";
}

function Cat(name){
    this.name=name;
}
Cat.prototype=new Mammal;      //inherit from Mammal
Cat.prototype.constructor=Cat; //but keep the correct constructor

var bob = new Mammal('Bob');
var kitty = new Cat('Felix');

bob.toString();   //returns the string "[Mammal 'Bob']"
kitty.toString(); //returns the string "[Cat 'Felix']"
]]>
</description>
        </property>
      </properties>
      <insert>constructor</insert>
    </element>
    <element kind="var" name="Boolean_prototype">
      <note title="overview">The prototype for a class. Property Type: Object</note>
      <properties>
        <property kind="example">
          <description>
            <![CDATA[ This property is read-only for intrinsic JS classes (e.g. the Date object) but may be re-assigned for user-defined classes.

While the prototype property is 'read-only' for intrinsic classes, it may be used to extend their functionality. For example the following code uses the prototype property of the Number object to extend all numbers to support a custom 'truncate' method:

Number.prototype.trunctate=function(){
        return this>0?Math.floor(this):Math.ceil(this);
}
var x=12.37;
var y=-12.37;

x = x.truncate(); // ** 12
y = y.truncate(); // ** -12

The following code sample shows how to use the prototype property to cause one class to inherit from another:

function Mammal(name){ 
        this.name=name;
        this.offspring=[];
} 
Mammal.prototype.haveABaby=function(){ 
        var newBaby=new this.constructor("Baby "+this.name); //Uses Cat for cats, Mammal for Mammals
        this.offspring.push(newBaby);
        return newBaby;
} 
Mammal.prototype.toString=function(){ 
        return '[Mammal "'+this.name+'"]';
} 


Cat.prototype = new Mammal;          // Here's where the inheritance occurs 
Cat.prototype.constructor=Cat;       // Otherwise instances of Cat would have a constructor of Mammal 
function Cat(name){ 
        this.name=name;
} 
Cat.prototype.toString=function(){ 
        return '[Cat "'+this.name+'"]';
} 

var msg;

var someAnimal = new Mammal('Mr. Biggles');
msg = 'someAnimal is '+someAnimal;         // ** 'someAnimal is [Mammal "Mr. Biggles"]'

var myPet = new Cat('Felix');
msg = 'myPet is '+myPet;                   // ** 'myPet is [Cat "Felix"]' 

myPet.haveABaby();                         // calls a method inherited from Mammal 
msg = myPet.offspring.length;              // ** 1
msg = "First baby is "+myPet.offspring[0]; // ** 'First baby is [Cat "Baby Felix"]'
]]>
</description>
        </property>
      </properties>
      <insert>prototype</insert>
    </element>
    <element kind="function" name="Boolean_hasOwnProperty()">
      <note title="overview">Determines if the object/instance itself has the named property or method. Return Type: Boolean</note>
      <insert>hasOwnProperty(%_)</insert>
      <properties>
        <property kind="parameter" name="propertyOrMethodName">
          <description>String The name of the property or method to look for in the object.</description>
        </property>
        <property kind="example">
          <description>
            <![CDATA[ This method returns true of the specific object instance or prototype has a property or method with the name specified. The inheritance chain is not searched. The following example illustrates this:
function Person(){ ... }
Person.prototype.breathe=function(){ ... }
var fredAstaire = new Person();
fredAstaire.dance = function(){ ... }

if (Person.prototype.hasOwnProperty('breathe')){
        // this code will execute...the above call will return true
}
if (fredAstaire.hasOwnProperty('breathe')){
        // this code will NOT execute...
        // fredAstaire knows how to 'breathe', but this is an inherited method
}
if (fredAstaire.hasOwnProperty('dance')){
        // this code will execute...the above call will return true
}
if (Person.prototype.hasOwnProperty('dance')){
        // this code will NOT execute...
        // not every Person knows how to dance
}

]]>
</description>
        </property>
      </properties>
    </element>
    <element kind="function" name="Boolean_isPrototypeOf()">
      <note title="overview">Determines if the calling object prototype is in the inheritance chain for the supplied argument. Return Type: Boolean</note>
      <insert>isPrototypeOf(%_)</insert>
      <properties>
        <property kind="parameter" name="instanceToTest">
          <description>Object The object instance to check.</description>
        </property>
        <property kind="example">
          <description>
            <![CDATA[ The following code sample shows how to use this method to test if an object instance inherits from the calling prototype:
function Mammal(){ ... }
function Human(){ ... }
Human.prototype = new Mammal; //Human inherits from Mammal
var billGates = new Human();
if (Human.isPrototypeOf(billGates)){
        //this code will NOT run...
        //you must call this method on a prototype object
}
if (Human.prototype.isPrototypeOf(billGates)){
        //this code will run...the above will return true
}
if (Mammal.prototype.isPrototypeOf(billGates)){
        //this code will run...the above will return true
}
]]>
</description>
        </property>
      </properties>
    </element>
    <element kind="function" name="Boolean_propertyIsEnumerable()">
      <note title="overview">Determines if the object/instance itself has a property or method of the supplied name which will appear in a for (prop in obj) enumeration. Return Type: Boolean</note>
      <insert>propertyIsEnumerable(%_)</insert>
      <properties>
        <property kind="parameter" name="propertyOrMethodName">
          <description>String The name of the property or method to look for.</description>
        </property>
        <property kind="example">
          <description>
            <![CDATA[ This method does not search the inheritance chain of any instance supplied. Returns false if no property/method of the supplied name exists, or if one exists but will not appear during enumeration.

In general, built-in properties and methods are not enumerable, while user-defined properties and methods are.
]]>
</description>
        </property>
      </properties>
    </element>
    <element kind="function" name="Boolean_toLocaleString()">
      <note title="overview">For most objects, the same as toString() unless explicitly overridden. Return Type: String (this method takes no arguments)</note>
      <insert>toLocaleString()</insert>
      <properties>
        <property kind="example">
          <description>
            <![CDATA[ 
]]>
</description>
        </property>
      </properties>
    </element>
    <element kind="function" name="Boolean_toString()">
      <note title="overview">Returns a string representation of the object. Return Type: String (this method takes no arguments)</note>
      <insert>toString()</insert>
      <properties>
        <property kind="example">
          <description>
            <![CDATA[ For most objects, returns the string "[object "+className+"]". For internal objects, returns the following:ArrayEach member of the array has toString() called on it, and the results are joined together with commas. Equivalent to myArray.join().BooleanReturns "true" for true, "false" for false.DateThe format of the string value returned depends on the implementation. Often a human-readable string such as "Mon Nov 17 2003 13:56:48 GMT-0700"FunctionThe format of the string value returned depends on the implementation. Often a source-code representation of the function.NumberThe number converted to a string value. (See the specific entry for Number.toString(radix).)StringThe string's value.
</elem>]]>
</description>
        </property>
      </properties>
    </element>
    <element kind="function" name="Boolean_valueOf()">
      <note title="overview">Returns the internal this value of the object. Return Type: String (this method takes no arguments)</note>
      <insert>valueOf()</insert>
      <properties>
        <property kind="example">
          <description>
            <![CDATA[ For various intrinsic JS object types, this value returned is overridden and customized as follows:ArraySame as the Array.toString() method.Boolean(unchanged) The true/false value itself.DateA Number object with an integer value representing the time in milliseconds since Midnight, January 1st, 1970 UTC.Function(unchanged) A reference to the function object itself.Number(unchanged) The number value itself.Object(unchanged) A reference to the object itself.StringThe string's value.
]]>
</description>
        </property>
      </properties>
    </element>
  </group>
  <group name="Date">
    <note title="overview">Date/time value. Inherits from: Object</note>
    <element kind="var" name="Date_constructor">
      <note title="overview">A reference to the constructor class for the current object instance. Property Type: Object</note>
      <properties>
        <property kind="example">
          <description>
            <![CDATA[ Checking the constructor property for a custom object is a clean way to see its type. The following code takes objects of most any type and returns a string representation of them, suitable for use in source code. Note how the constructor property is used to check the object type of the parameter.

//For more information on this function, see http://phrogz.net/JS/Object.prototype.toSourceCode.js
Object.prototype.toSourceCode=function(hier,lv,forObj){
    var out,tabs='',idre=/^[a-z_][a-z0-9_]*$/i;
    if (!lv) lv=0;
    if (hier) tabs=Math.pow(10,lv).toString().substr(1).replace(/0/g,"\t");
    if (this.constructor==Array){
        out=(forObj?'':tabs)+'['+(hier?'\n':'');
        for (var i=0,len=this.length;i&amp;lt;len;i++){
            out+=((this[i]!=null)?this[i].toSourceCode(hier,lv+1):'null')
                +(i&amp;lt;(len-1)?',':'')+(hier?'\n':'');
        }
        return out+tabs+']';
    }else if(this.constructor==Object){
        out=(forObj?'':tabs)+'{'+(hier?'\n':'');
        for (var key in this){
            if (key!='toSourceCode'){
                out+=tabs+(hier?'\t':'')
                    +(idre.test(key)?key:("'"+key+"'"))
                    +":"+(this[key]==null?'null':this[key].toSourceCode(hier,lv+1,true))
                    +","+(hier?'\n':'');
            }
        }
        out=out.replace(/,(\n?)$/,'$1');
        return out+tabs+'}';
    }else if(this.constructor==String) return (forObj?'':tabs)+"'"+this+"'";
    else if(this.constructor==Date) return (forObj?'':tabs)+"new Date("+this.valueOf()+")";
    else return (forObj?'':tabs)+this.toString();
}

The constructor property is especially useful for distinguishing arrays from generic objects, since (per the spec) typeof(myArray) returns the string "object". The following example detects if the returned value is an array or not; if it's not, it is turned into a single-element array.

(In HTML, asking for a form element by name returns the element itself if only one named element exists, or returns an array of elements if more than one name exists. It is often convenient to treat both cases with the same code, which expects an array.)

var myForm=document.getElementById('myFormID');
var products = myForm.elements['product'];
if (products.constructor!=Array) products=[products];

The value of the constructor property is not limited to the built-in object types. The following example shows two custom classes, Mammal and Cat, where a method of the class detects the type of the instance.

function Mammal(name){
    this.name=name;
}
Mammal.prototype.toString=function(){
    if (this.constructor==Cat) return "[Cat '"+this.name+"']";
    else return "[Mammal '"+this.name+"']";
}

function Cat(name){
    this.name=name;
}
Cat.prototype=new Mammal;      //inherit from Mammal
Cat.prototype.constructor=Cat; //but keep the correct constructor

var bob = new Mammal('Bob');
var kitty = new Cat('Felix');

bob.toString();   //returns the string "[Mammal 'Bob']"
kitty.toString(); //returns the string "[Cat 'Felix']"
]]>
</description>
        </property>
      </properties>
      <insert>constructor</insert>
    </element>
    <element kind="var" name="Date_prototype">
      <note title="overview">The prototype for a class. Property Type: Object</note>
      <properties>
        <property kind="example">
          <description>
            <![CDATA[ This property is read-only for intrinsic JS classes (e.g. the Date object) but may be re-assigned for user-defined classes.

While the prototype property is 'read-only' for intrinsic classes, it may be used to extend their functionality. For example the following code uses the prototype property of the Number object to extend all numbers to support a custom 'truncate' method:

Number.prototype.trunctate=function(){
        return this>0?Math.floor(this):Math.ceil(this);
}
var x=12.37;
var y=-12.37;

x = x.truncate(); // ** 12
y = y.truncate(); // ** -12

The following code sample shows how to use the prototype property to cause one class to inherit from another:

function Mammal(name){ 
        this.name=name;
        this.offspring=[];
} 
Mammal.prototype.haveABaby=function(){ 
        var newBaby=new this.constructor("Baby "+this.name); //Uses Cat for cats, Mammal for Mammals
        this.offspring.push(newBaby);
        return newBaby;
} 
Mammal.prototype.toString=function(){ 
        return '[Mammal "'+this.name+'"]';
} 


Cat.prototype = new Mammal;          // Here's where the inheritance occurs 
Cat.prototype.constructor=Cat;       // Otherwise instances of Cat would have a constructor of Mammal 
function Cat(name){ 
        this.name=name;
} 
Cat.prototype.toString=function(){ 
        return '[Cat "'+this.name+'"]';
} 

var msg;

var someAnimal = new Mammal('Mr. Biggles');
msg = 'someAnimal is '+someAnimal;         // ** 'someAnimal is [Mammal "Mr. Biggles"]'

var myPet = new Cat('Felix');
msg = 'myPet is '+myPet;                   // ** 'myPet is [Cat "Felix"]' 

myPet.haveABaby();                         // calls a method inherited from Mammal 
msg = myPet.offspring.length;              // ** 1
msg = "First baby is "+myPet.offspring[0]; // ** 'First baby is [Cat "Baby Felix"]'
]]>
</description>
        </property>
      </properties>
      <insert>prototype</insert>
    </element>
    <element kind="function" name="Date_UTC()">
      <note title="overview">Return the number of milliseconds corresponding to the supplied arguments. Return Type: Number</note>
      <insert>UTC(%_)</insert>
      <properties>
        <property kind="parameter" name="year">
          <description>Number The UTC year number.</description>
        </property>
        <property kind="parameter" name="month">
          <description>Number The zero-based UTC month number.</description>
        </property>
        <property kind="parameter" name="day">
          <description>Number [optional] The UTC day number.</description>
        </property>
        <property kind="parameter" name="hour">
          <description>Number [optional] The UTC hours.</description>
        </property>
        <property kind="parameter" name="minute">
          <description>Number [optional] The UTC minutes.</description>
        </property>
        <property kind="parameter" name="second">
          <description>Number [optional] The UTC seconds.</description>
        </property>
        <property kind="parameter" name="ms">
          <description>Number [optional] The UTC milliseconds.</description>
        </property>
        <property kind="example">
          <description>
            <![CDATA[ This method applies to the Date class, not a particular instance; appropriate usage is:

var numMilliseconds = Date.UTC(...);

This method is used by the new Date() constructor when more than one argument is passed, so the following two methods of creating a date are equivalent:

var numMilliseconds = Date.UTC(2003,11,24);
var myDate1 = new Date(numMilliseconds);

var myDate2 = new Date(2003,11,24);
var numMilliseconds = myDate2.valueOf();

As such, this method is solely useful when only the date value (as a number) is important instead of the full Date object it represents.

Note: The month property is zero-based; 0 corresponds to January, and (as above) 11 corresponds to December.
]]>
</description>
        </property>
      </properties>
    </element>
    <element kind="function" name="Date_getDate()">
      <note title="overview">Return the day number in the local timezone. Return Type: Number (this method takes no arguments)</note>
      <insert>getDate()</insert>
      <properties>
        <property kind="example">
          <description>
            <![CDATA[ 
]]>
</description>
        </property>
      </properties>
    </element>
    <element kind="function" name="Date_getDay()">
      <note title="overview">Return the zero-based weekday number in the local timezone. Return Type: Number (this method takes no arguments)</note>
      <insert>getDay()</insert>
      <properties>
        <property kind="example">
          <description>
            <![CDATA[ 
]]>
</description>
        </property>
      </properties>
    </element>
    <element kind="function" name="Date_getFullYear()">
      <note title="overview">Return the four-digit year in the local timezone. Return Type: Number (this method takes no arguments)</note>
      <insert>getFullYear()</insert>
      <properties>
        <property kind="example">
          <description>
            <![CDATA[ This method is the replacement for the ill-designed getYear() method which returned the year number - 100.

var bday = new Date("12/31/2003");
var year = bday.getYear();     // ** 103 .. totally useless :)
var year = bday.getFullYear(); // ** 2003

To get a two-digit version of the year (did Y2k teach us nothing?!) convert it to a string and use String.slice():

var bday = new Date("12/31/2003");
var twoDigitYear = bday.getFullYear().toString().slice(-2);  // ** "03"
]]>
</description>
        </property>
      </properties>
    </element>
    <element kind="function" name="Date_getHours()">
      <note title="overview">Return the hour number in the local timezone. Return Type: Number (this method takes no arguments)</note>
      <insert>getHours()</insert>
      <properties>
        <property kind="example">
          <description>
            <![CDATA[ 
]]>
</description>
        </property>
      </properties>
    </element>
    <element kind="function" name="Date_getMilliseconds()">
      <note title="overview">Return the millisecond number in the local timezone. Return Type: Number (this method takes no arguments)</note>
      <insert>getMilliseconds()</insert>
      <properties>
        <property kind="example">
          <description>
            <![CDATA[ 
]]>
</description>
        </property>
      </properties>
    </element>
    <element kind="function" name="Date_getMinutes()">
      <note title="overview">Return the minute number in the local timezone. Return Type: Number (this method takes no arguments)</note>
      <insert>getMinutes()</insert>
      <properties>
        <property kind="example">
          <description>
            <![CDATA[ 
]]>
</description>
        </property>
      </properties>
    </element>
    <element kind="function" name="Date_getMonth()">
      <note title="overview">Return the zero-based month number in the local timezone. Return Type: Number (this method takes no arguments)</note>
      <insert>getMonth()</insert>
      <properties>
        <property kind="example">
          <description>
            <![CDATA[ 
]]>
</description>
        </property>
      </properties>
    </element>
    <element kind="function" name="Date_getSeconds()">
      <note title="overview">Return the second number in the local timezone. Return Type: Number (this method takes no arguments)</note>
      <insert>getSeconds()</insert>
      <properties>
        <property kind="example">
          <description>
            <![CDATA[ 
]]>
</description>
        </property>
      </properties>
    </element>
    <element kind="function" name="Date_getTime()">
      <note title="overview">Return the number of milliseconds since Midnight, Jan 1, 1970 UTC. Return Type: Number (this method takes no arguments)</note>
      <insert>getTime()</insert>
      <properties>
        <property kind="example">
          <description>
            <![CDATA[ 
]]>
</description>
        </property>
      </properties>
    </element>
    <element kind="function" name="Date_getTimezoneOffset()">
      <note title="overview">Returns the difference between the local time and UTC time in minutes. Return Type: Number (this method takes no arguments)</note>
      <insert>getTimezoneOffset()</insert>
      <properties>
        <property kind="example">
          <description>
            <![CDATA[ 
]]>
</description>
        </property>
      </properties>
    </element>
    <element kind="function" name="Date_getUTCDate()">
      <note title="overview">Return the day number in UTC. Return Type: Number (this method takes no arguments)</note>
      <insert>getUTCDate()</insert>
      <properties>
        <property kind="example">
          <description>
            <![CDATA[ 
]]>
</description>
        </property>
      </properties>
    </element>
    <element kind="function" name="Date_getUTCDay()">
      <note title="overview">Return the zero-based weekday number in UTC. Return Type: Number (this method takes no arguments)</note>
      <insert>getUTCDay()</insert>
      <properties>
        <property kind="example">
          <description>
            <![CDATA[ 
]]>
</description>
        </property>
      </properties>
    </element>
    <element kind="function" name="Date_getUTCFullYear()">
      <note title="overview">Return the four-digit year in UTC. Return Type: Number (this method takes no arguments)</note>
      <insert>getUTCFullYear()</insert>
      <properties>
        <property kind="example">
          <description>
            <![CDATA[ 
]]>
</description>
        </property>
      </properties>
    </element>
    <element kind="function" name="Date_getUTCHours()">
      <note title="overview">Return the hour number in UTC. Return Type: Number (this method takes no arguments)</note>
      <insert>getUTCHours()</insert>
      <properties>
        <property kind="example">
          <description>
            <![CDATA[ 
]]>
</description>
        </property>
      </properties>
    </element>
    <element kind="function" name="Date_getUTCMilliseconds()">
      <note title="overview">Return the millisecond number in UTC. Return Type: Number (this method takes no arguments)</note>
      <insert>getUTCMilliseconds()</insert>
      <properties>
        <property kind="example">
          <description>
            <![CDATA[ 
]]>
</description>
        </property>
      </properties>
    </element>
    <element kind="function" name="Date_getUTCMinutes()">
      <note title="overview">Return the minute number in UTC. Return Type: Number (this method takes no arguments)</note>
      <insert>getUTCMinutes()</insert>
      <properties>
        <property kind="example">
          <description>
            <![CDATA[ 
]]>
</description>
        </property>
      </properties>
    </element>
    <element kind="function" name="Date_getUTCMonth()">
      <note title="overview">Return the zero-based month number in UTC. Return Type: Number (this method takes no arguments)</note>
      <insert>getUTCMonth()</insert>
      <properties>
        <property kind="example">
          <description>
            <![CDATA[ 
]]>
</description>
        </property>
      </properties>
    </element>
    <element kind="function" name="Date_getUTCSeconds()">
      <note title="overview">Return the second number in UTC. Return Type: Number (this method takes no arguments)</note>
      <insert>getUTCSeconds()</insert>
      <properties>
        <property kind="example">
          <description>
            <![CDATA[ 
]]>
</description>
        </property>
      </properties>
    </element>
    <element kind="function" name="Date_hasOwnProperty()">
      <note title="overview">Determines if the object/instance itself has the named property or method. Return Type: Boolean</note>
      <insert>hasOwnProperty(%_)</insert>
      <properties>
        <property kind="parameter" name="propertyOrMethodName">
          <description>String The name of the property or method to look for in the object.</description>
        </property>
        <property kind="example">
          <description>
            <![CDATA[ This method returns true of the specific object instance or prototype has a property or method with the name specified. The inheritance chain is not searched. The following example illustrates this:
function Person(){ ... }
Person.prototype.breathe=function(){ ... }
var fredAstaire = new Person();
fredAstaire.dance = function(){ ... }

if (Person.prototype.hasOwnProperty('breathe')){
        // this code will execute...the above call will return true
}
if (fredAstaire.hasOwnProperty('breathe')){
        // this code will NOT execute...
        // fredAstaire knows how to 'breathe', but this is an inherited method
}
if (fredAstaire.hasOwnProperty('dance')){
        // this code will execute...the above call will return true
}
if (Person.prototype.hasOwnProperty('dance')){
        // this code will NOT execute...
        // not every Person knows how to dance
}

]]>
</description>
        </property>
      </properties>
    </element>
    <element kind="function" name="Date_isPrototypeOf()">
      <note title="overview">Determines if the calling object prototype is in the inheritance chain for the supplied argument. Return Type: Boolean</note>
      <insert>isPrototypeOf(%_)</insert>
      <properties>
        <property kind="parameter" name="instanceToTest">
          <description>Object The object instance to check.</description>
        </property>
        <property kind="example">
          <description>
            <![CDATA[ The following code sample shows how to use this method to test if an object instance inherits from the calling prototype:
function Mammal(){ ... }
function Human(){ ... }
Human.prototype = new Mammal; //Human inherits from Mammal
var billGates = new Human();
if (Human.isPrototypeOf(billGates)){
        //this code will NOT run...
        //you must call this method on a prototype object
}
if (Human.prototype.isPrototypeOf(billGates)){
        //this code will run...the above will return true
}
if (Mammal.prototype.isPrototypeOf(billGates)){
        //this code will run...the above will return true
}
]]>
</description>
        </property>
      </properties>
    </element>
    <element kind="function" name="Date_parse()">
      <note title="overview">Attempt to parse the supplied string as a date, and return the number of milliseconds it represents. Return Type: Number</note>
      <insert>parse(%_)</insert>
      <properties>
        <property kind="parameter" name="dateString">
          <description>String The string to parse as a date; may be a UTC time, a local time, or some other timezone.</description>
        </property>
        <property kind="example">
          <description>
            <![CDATA[ This method applies to the Date class, not a particular instance; appropriate usage is:

var numMilliseconds = Date.parse(...);

This method is used by the new Date() constructor when a single string value is passed as a parameter, so the following two methods of creating a date are equivalent:

var numMilliseconds = Date.parse("12/24/2003 3:15 pm");
var myDate1 = new Date(numMilliseconds);

var myDate2 = new Date("12/24/2003 3:15 pm");
var numMilliseconds = myDate2.valueOf();

As such, this method is solely useful when only the date value (as a number) is important instead of the full Date object it represents.
]]>
</description>
        </property>
      </properties>
    </element>
    <element kind="function" name="Date_propertyIsEnumerable()">
      <note title="overview">Determines if the object/instance itself has a property or method of the supplied name which will appear in a for (prop in obj) enumeration. Return Type: Boolean</note>
      <insert>propertyIsEnumerable(%_)</insert>
      <properties>
        <property kind="parameter" name="propertyOrMethodName">
          <description>String The name of the property or method to look for.</description>
        </property>
        <property kind="example">
          <description>
            <![CDATA[ This method does not search the inheritance chain of any instance supplied. Returns false if no property/method of the supplied name exists, or if one exists but will not appear during enumeration.

In general, built-in properties and methods are not enumerable, while user-defined properties and methods are.
]]>
</description>
        </property>
      </properties>
    </element>
    <element kind="function" name="Date_setDate()">
      <note title="overview">Set the day number in the local timezone. Return Type: Number</note>
      <insert>setDate(%_)</insert>
      <properties>
        <property kind="parameter" name="day">
          <description>Number The new day number, expressed in the local timezone.</description>
        </property>
        <property kind="example">
          <description>
            <![CDATA[ 
]]>
</description>
        </property>
      </properties>
    </element>
    <element kind="function" name="Date_setFullYear()">
      <note title="overview">Set the year, expressed in the local timezone. Return Type: Number</note>
      <insert>setFullYear(%_)</insert>
      <properties>
        <property kind="parameter" name="year">
          <description>Number The new year number, expressed in the local timezone.</description>
        </property>
        <property kind="parameter" name="month">
          <description>Number [optional] The new month number, expressed in the local timezone. (0=January, 1=February, etc.)</description>
        </property>
        <property kind="parameter" name="day">
          <description>Number [optional] The new day number, expressed in the local timezone.</description>
        </property>
        <property kind="example">
          <description>
            <![CDATA[ If the optional parameters are omitted, they are left unchanged in the date object.
]]>
</description>
        </property>
      </properties>
    </element>
    <element kind="function" name="Date_setHours()">
      <note title="overview">Set the hour number in the local timezone. Return Type: Number</note>
      <insert>setHours(%_)</insert>
      <properties>
        <property kind="parameter" name="hours">
          <description>Number The new hour number, expressed in the local timezone.</description>
        </property>
        <property kind="parameter" name="mins">
          <description>Number [optional] The new minute number, expressed in the local timezone.</description>
        </property>
        <property kind="parameter" name="secs">
          <description>Number [optional] The new second number, expressed in the local timezone.</description>
        </property>
        <property kind="parameter" name="ms">
          <description>Number [optional] The new milliseconds, expressed in the local timezone.</description>
        </property>
        <property kind="example">
          <description>
            <![CDATA[ If the optional parameters are omitted, they are left unchanged in the date object.
]]>
</description>
        </property>
      </properties>
    </element>
    <element kind="function" name="Date_setMilliseconds()">
      <note title="overview">Set the millisecond number in the local timezone. Return Type: Number</note>
      <insert>setMilliseconds(%_)</insert>
      <properties>
        <property kind="parameter" name="ms">
          <description>Number The new milliseconds, expressed in the local timezone.</description>
        </property>
        <property kind="example">
          <description>
            <![CDATA[ 
]]>
</description>
        </property>
      </properties>
    </element>
    <element kind="function" name="Date_setMinutes()">
      <note title="overview">Set the minute number in the local timezone. Return Type: Number</note>
      <insert>setMinutes(%_)</insert>
      <properties>
        <property kind="parameter" name="mins">
          <description>Number The new minute number, expressed in the local timezone.</description>
        </property>
        <property kind="parameter" name="secs">
          <description>Number [optional] The new second number, expressed in the local timezone.</description>
        </property>
        <property kind="parameter" name="ms">
          <description>Number [optional] The new milliseconds, expressed in the local timezone.</description>
        </property>
        <property kind="example">
          <description>
            <![CDATA[ If the optional parameters are omitted, they are left unchanged in the date object.
]]>
</description>
        </property>
      </properties>
    </element>
    <element kind="function" name="Date_setMonth()">
      <note title="overview">Set the zero-based month, expressed in the local timezone. Return Type: Number</note>
      <insert>setMonth(%_)</insert>
      <properties>
        <property kind="parameter" name="month">
          <description>Number The new month number, expressed in the local timezone. (0=January, 1=February, etc.)</description>
        </property>
        <property kind="parameter" name="day">
          <description>Number [optional] The new day number, expressed in the local timezone.</description>
        </property>
        <property kind="example">
          <description>
            <![CDATA[ If the optional day parameter is omitted, it is left unchanged in the date object.
]]>
</description>
        </property>
      </properties>
    </element>
    <element kind="function" name="Date_setSeconds()">
      <note title="overview">Set the second number in the local timezone. Return Type: Number</note>
      <insert>setSeconds(%_)</insert>
      <properties>
        <property kind="parameter" name="second">
          <description>Number The new seconds, expressed in the local timezone.</description>
        </property>
        <property kind="parameter" name="ms">
          <description>Number [optional] The new milliseconds, expressed in the local timezone.</description>
        </property>
        <property kind="example">
          <description>
            <![CDATA[ If the optional ms parameter is omitted, it is left unchanged in the date object.
]]>
</description>
        </property>
      </properties>
    </element>
    <element kind="function" name="Date_setTime()">
      <note title="overview">Set the date object to a new time. Return Type: Number</note>
      <insert>setTime(%_)</insert>
      <properties>
        <property kind="parameter" name="time">
          <description>Number The new time, expressed as milliseconds since Midnight, January 1st, 1970</description>
        </property>
        <property kind="example">
          <description>
            <![CDATA[ 
]]>
</description>
        </property>
      </properties>
    </element>
    <element kind="function" name="Date_setUTCDate()">
      <note title="overview">Set the UTC day number. Return Type: Number</note>
      <insert>setUTCDate(%_)</insert>
      <properties>
        <property kind="parameter" name="day">
          <description>Number The new day number, expressed in UTC.</description>
        </property>
        <property kind="example">
          <description>
            <![CDATA[ 
]]>
</description>
        </property>
      </properties>
    </element>
    <element kind="function" name="Date_setUTCFullYear()">
      <note title="overview">Set the UTC year number. Return Type: Number</note>
      <insert>setUTCFullYear(%_)</insert>
      <properties>
        <property kind="parameter" name="year">
          <description>Number The new year number, expressed in UTC.</description>
        </property>
        <property kind="parameter" name="month">
          <description>Number [optional] The new month number, expressed in UTC.</description>
        </property>
        <property kind="parameter" name="day">
          <description>Number [optional] The new day number, expressed in UTC.</description>
        </property>
        <property kind="example">
          <description>
            <![CDATA[ If the optional parameters are omitted, they are left unchanged in the date object.
]]>
</description>
        </property>
      </properties>
    </element>
    <element kind="function" name="Date_setUTCHours()">
      <note title="overview">Set the UTC hours. Return Type: Number</note>
      <insert>setUTCHours(%_)</insert>
      <properties>
        <property kind="parameter" name="hours">
          <description>Number The new hour number, expressed in UTC.</description>
        </property>
        <property kind="parameter" name="mins">
          <description>Number [optional] The new minute number, expressed in UTC.</description>
        </property>
        <property kind="parameter" name="secs">
          <description>Number [optional] The new second number, expressed in UTC.</description>
        </property>
        <property kind="parameter" name="ms">
          <description>Number [optional] The new milliseconds, expressed in UTC.</description>
        </property>
        <property kind="example">
          <description>
            <![CDATA[ If the optional parameters are omitted, they are left unchanged in the date object.
]]>
</description>
        </property>
      </properties>
    </element>
    <element kind="function" name="Date_setUTCMilliseconds()">
      <note title="overview">Set the UTC milliseconds. Return Type: Number</note>
      <insert>setUTCMilliseconds(%_)</insert>
      <properties>
        <property kind="parameter" name="ms">
          <description>Number [optional] The new milliseconds, expressed in UTC.</description>
        </property>
        <property kind="example">
          <description>
            <![CDATA[ 
]]>
</description>
        </property>
      </properties>
    </element>
    <element kind="function" name="Date_setUTCMinutes()">
      <note title="overview">Set the UTC minutes. Return Type: Number</note>
      <insert>setUTCMinutes(%_)</insert>
      <properties>
        <property kind="parameter" name="mins">
          <description>Number The new minute number, expressed in UTC.</description>
        </property>
        <property kind="parameter" name="secs">
          <description>Number [optional] The new second number, expressed in UTC.</description>
        </property>
        <property kind="parameter" name="ms">
          <description>Number [optional] The new milliseconds, expressed in UTC.</description>
        </property>
        <property kind="example">
          <description>
            <![CDATA[ If the optional parameters are omitted, they are left unchanged in the date object.
]]>
</description>
        </property>
      </properties>
    </element>
    <element kind="function" name="Date_setUTCMonth()">
      <note title="overview">Set the UTC month. Return Type: Number</note>
      <insert>setUTCMonth(%_)</insert>
      <properties>
        <property kind="parameter" name="month">
          <description>Number The new zero-based month number, expressed in UTC. (0=January, 1=February, etc.)</description>
        </property>
        <property kind="parameter" name="day">
          <description>Number [optional] The new day number, expressed in UTC.</description>
        </property>
        <property kind="example">
          <description>
            <![CDATA[ If the optional day parameter is omitted, it is left unchanged in the date object.
]]>
</description>
        </property>
      </properties>
    </element>
    <element kind="function" name="Date_setUTCSeconds()">
      <note title="overview">Set the UTC seconds. Return Type: Number</note>
      <insert>setUTCSeconds(%_)</insert>
      <properties>
        <property kind="parameter" name="secs">
          <description>Number The new second number, expressed in UTC.</description>
        </property>
        <property kind="parameter" name="ms">
          <description>Number [optional] The new milliseconds, expressed in UTC.</description>
        </property>
        <property kind="example">
          <description>
            <![CDATA[ 
]]>
</description>
        </property>
      </properties>
    </element>
    <element kind="function" name="Date_toDateString()">
      <note title="overview">Return a string version of the date-only portion of the object. Return Type: String (this method takes no arguments)</note>
      <insert>toDateString()</insert>
      <properties>
        <property kind="example">
          <description>
            <![CDATA[ The actual format of the string is specific to the ECMAScript intermpretter (and possibly the locale). The following output is an example from Mozilla's SpiderMonkey interpretter:

var myDate = new Date(2003,11,18,16,15,27,813);
var theDate = myDate.toDateString();
var theTime = myDate.toTimeString();
// ** theDate is "Thu Dec 18 2003"
// ** theTime is "16:15:27 GMT-0700 (MST)"
]]>
</description>
        </property>
      </properties>
    </element>
    <element kind="function" name="Date_toLocaleString()">
      <note title="overview">For most objects, the same as toString() unless explicitly overridden. Return Type: String (this method takes no arguments)</note>
      <insert>toLocaleString()</insert>
      <properties>
        <property kind="example">
          <description>
            <![CDATA[ 
]]>
</description>
        </property>
      </properties>
    </element>
    <element kind="function" name="Date_toString()">
      <note title="overview">Returns a string representation of the object. Return Type: String (this method takes no arguments)</note>
      <insert>toString()</insert>
      <properties>
        <property kind="example">
          <description>
            <![CDATA[ For most objects, returns the string "[object "+className+"]". For internal objects, returns the following:ArrayEach member of the array has toString() called on it, and the results are joined together with commas. Equivalent to myArray.join().BooleanReturns "true" for true, "false" for false.DateThe format of the string value returned depends on the implementation. Often a human-readable string such as "Mon Nov 17 2003 13:56:48 GMT-0700"FunctionThe format of the string value returned depends on the implementation. Often a source-code representation of the function.NumberThe number converted to a string value. (See the specific entry for Number.toString(radix).)StringThe string's value.
</elem>]]>
</description>
        </property>
      </properties>
    </element>
    <element kind="function" name="Date_toTimeString()">
      <note title="overview">Return a string version of the time-only portion of the object. Return Type: String (this method takes no arguments)</note>
      <insert>toTimeString()</insert>
      <properties>
        <property kind="example">
          <description>
            <![CDATA[ 
]]>
</description>
        </property>
      </properties>
    </element>
    <element kind="function" name="Date_toUTCString()">
      <note title="overview">Returns a string form of the Date in a convenient, human-readable form in UTC. Return Type: String (this method takes no arguments)</note>
      <insert>toUTCString()</insert>
      <properties>
        <property kind="example">
          <description>
            <![CDATA[ The actual format of the string is not specified in the ECMAScript specifications, and hence may be implementation-dependant.

Note that this is the official method which replaced Date.toGMTString(); though they behave identically, Date.toUTCString() is part of the standard, and Date.toGMTString() is not.

</elem>]]>
</description>
        </property>
      </properties>
    </element>
    <element kind="function" name="Date_valueOf()">
      <note title="overview">Returns the internal this value of the object. Return Type: String (this method takes no arguments)</note>
      <insert>valueOf()</insert>
      <properties>
        <property kind="example">
          <description>
            <![CDATA[ For various intrinsic JS object types, this value returned is overridden and customized as follows:ArraySame as the Array.toString() method.Boolean(unchanged) The true/false value itself.DateA Number object with an integer value representing the time in milliseconds since Midnight, January 1st, 1970 UTC.Function(unchanged) A reference to the function object itself.Number(unchanged) The number value itself.Object(unchanged) A reference to the object itself.StringThe string's value.
]]>
</description>
        </property>
      </properties>
    </element>
    <element kind="function" name="Date_parse()">
      <note title="overview">Attempt to parse the supplied string as a date, and return the number of milliseconds it represents. Return Type: Number</note>
      <insert>parse(%_)</insert>
      <properties>
        <property kind="parameter" name="dateString">
          <description>String The string to parse as a date; may be a UTC time, a local time, or some other timezone.</description>
        </property>
        <property kind="example">
          <description>
            <![CDATA[ This method applies to the Date class, not a particular instance; appropriate usage is:

var numMilliseconds = Date.parse(...);

This method is used by the new Date() constructor when a single string value is passed as a parameter, so the following two methods of creating a date are equivalent:

var numMilliseconds = Date.parse("12/24/2003 3:15 pm");
var myDate1 = new Date(numMilliseconds);

var myDate2 = new Date("12/24/2003 3:15 pm");
var numMilliseconds = myDate2.valueOf();

As such, this method is solely useful when only the date value (as a number) is important instead of the full Date object it represents.
]]>
</description>
        </property>
      </properties>
    </element>
    <element kind="function" name="Date_UTC()">
      <note title="overview">Return the number of milliseconds corresponding to the supplied arguments. Return Type: Number</note>
      <insert>UTC(%_)</insert>
      <properties>
        <property kind="parameter" name="year">
          <description>Number The UTC year number.</description>
        </property>
        <property kind="parameter" name="month">
          <description>Number The zero-based UTC month number.</description>
        </property>
        <property kind="parameter" name="day">
          <description>Number [optional] The UTC day number.</description>
        </property>
        <property kind="parameter" name="hour">
          <description>Number [optional] The UTC hours.</description>
        </property>
        <property kind="parameter" name="minute">
          <description>Number [optional] The UTC minutes.</description>
        </property>
        <property kind="parameter" name="second">
          <description>Number [optional] The UTC seconds.</description>
        </property>
        <property kind="parameter" name="ms">
          <description>Number [optional] The UTC milliseconds.</description>
        </property>
        <property kind="example">
          <description>
            <![CDATA[ This method applies to the Date class, not a particular instance; appropriate usage is:

var numMilliseconds = Date.UTC(...);

This method is used by the new Date() constructor when more than one argument is passed, so the following two methods of creating a date are equivalent:

var numMilliseconds = Date.UTC(2003,11,24);
var myDate1 = new Date(numMilliseconds);

var myDate2 = new Date(2003,11,24);
var numMilliseconds = myDate2.valueOf();

As such, this method is solely useful when only the date value (as a number) is important instead of the full Date object it represents.

Note: The month property is zero-based; 0 corresponds to January, and (as above) 11 corresponds to December.
]]>
</description>
        </property>
      </properties>
    </element>
  </group>
  <group name="Error">
    <note title="overview">Object to hold information about errors. Inherits from: Object</note>
    <element kind="var" name="Error_constructor">
      <note title="overview">A reference to the constructor class for the current object instance. Property Type: Object</note>
      <properties>
        <property kind="example">
          <description>
            <![CDATA[ Checking the constructor property for a custom object is a clean way to see its type. The following code takes objects of most any type and returns a string representation of them, suitable for use in source code. Note how the constructor property is used to check the object type of the parameter.

//For more information on this function, see http://phrogz.net/JS/Object.prototype.toSourceCode.js
Object.prototype.toSourceCode=function(hier,lv,forObj){
    var out,tabs='',idre=/^[a-z_][a-z0-9_]*$/i;
    if (!lv) lv=0;
    if (hier) tabs=Math.pow(10,lv).toString().substr(1).replace(/0/g,"\t");
    if (this.constructor==Array){
        out=(forObj?'':tabs)+'['+(hier?'\n':'');
        for (var i=0,len=this.length;i&amp;lt;len;i++){
            out+=((this[i]!=null)?this[i].toSourceCode(hier,lv+1):'null')
                +(i&amp;lt;(len-1)?',':'')+(hier?'\n':'');
        }
        return out+tabs+']';
    }else if(this.constructor==Object){
        out=(forObj?'':tabs)+'{'+(hier?'\n':'');
        for (var key in this){
            if (key!='toSourceCode'){
                out+=tabs+(hier?'\t':'')
                    +(idre.test(key)?key:("'"+key+"'"))
                    +":"+(this[key]==null?'null':this[key].toSourceCode(hier,lv+1,true))
                    +","+(hier?'\n':'');
            }
        }
        out=out.replace(/,(\n?)$/,'$1');
        return out+tabs+'}';
    }else if(this.constructor==String) return (forObj?'':tabs)+"'"+this+"'";
    else if(this.constructor==Date) return (forObj?'':tabs)+"new Date("+this.valueOf()+")";
    else return (forObj?'':tabs)+this.toString();
}

The constructor property is especially useful for distinguishing arrays from generic objects, since (per the spec) typeof(myArray) returns the string "object". The following example detects if the returned value is an array or not; if it's not, it is turned into a single-element array.

(In HTML, asking for a form element by name returns the element itself if only one named element exists, or returns an array of elements if more than one name exists. It is often convenient to treat both cases with the same code, which expects an array.)

var myForm=document.getElementById('myFormID');
var products = myForm.elements['product'];
if (products.constructor!=Array) products=[products];

The value of the constructor property is not limited to the built-in object types. The following example shows two custom classes, Mammal and Cat, where a method of the class detects the type of the instance.

function Mammal(name){
    this.name=name;
}
Mammal.prototype.toString=function(){
    if (this.constructor==Cat) return "[Cat '"+this.name+"']";
    else return "[Mammal '"+this.name+"']";
}

function Cat(name){
    this.name=name;
}
Cat.prototype=new Mammal;      //inherit from Mammal
Cat.prototype.constructor=Cat; //but keep the correct constructor

var bob = new Mammal('Bob');
var kitty = new Cat('Felix');

bob.toString();   //returns the string "[Mammal 'Bob']"
kitty.toString(); //returns the string "[Cat 'Felix']"
]]>
</description>
        </property>
      </properties>
      <insert>constructor</insert>
    </element>
    <element kind="var" name="Error_prototype">
      <note title="overview">The prototype for a class. Property Type: Object</note>
      <properties>
        <property kind="example">
          <description>
            <![CDATA[ This property is read-only for intrinsic JS classes (e.g. the Date object) but may be re-assigned for user-defined classes.

While the prototype property is 'read-only' for intrinsic classes, it may be used to extend their functionality. For example the following code uses the prototype property of the Number object to extend all numbers to support a custom 'truncate' method:

Number.prototype.trunctate=function(){
        return this>0?Math.floor(this):Math.ceil(this);
}
var x=12.37;
var y=-12.37;

x = x.truncate(); // ** 12
y = y.truncate(); // ** -12

The following code sample shows how to use the prototype property to cause one class to inherit from another:

function Mammal(name){ 
        this.name=name;
        this.offspring=[];
} 
Mammal.prototype.haveABaby=function(){ 
        var newBaby=new this.constructor("Baby "+this.name); //Uses Cat for cats, Mammal for Mammals
        this.offspring.push(newBaby);
        return newBaby;
} 
Mammal.prototype.toString=function(){ 
        return '[Mammal "'+this.name+'"]';
} 


Cat.prototype = new Mammal;          // Here's where the inheritance occurs 
Cat.prototype.constructor=Cat;       // Otherwise instances of Cat would have a constructor of Mammal 
function Cat(name){ 
        this.name=name;
} 
Cat.prototype.toString=function(){ 
        return '[Cat "'+this.name+'"]';
} 

var msg;

var someAnimal = new Mammal('Mr. Biggles');
msg = 'someAnimal is '+someAnimal;         // ** 'someAnimal is [Mammal "Mr. Biggles"]'

var myPet = new Cat('Felix');
msg = 'myPet is '+myPet;                   // ** 'myPet is [Cat "Felix"]' 

myPet.haveABaby();                         // calls a method inherited from Mammal 
msg = myPet.offspring.length;              // ** 1
msg = "First baby is "+myPet.offspring[0]; // ** 'First baby is [Cat "Baby Felix"]'
]]>
</description>
        </property>
      </properties>
      <insert>prototype</insert>
    </element>
    <element kind="function" name="Error_hasOwnProperty()">
      <note title="overview">Determines if the object/instance itself has the named property or method. Return Type: Boolean</note>
      <insert>hasOwnProperty(%_)</insert>
      <properties>
        <property kind="parameter" name="propertyOrMethodName">
          <description>String The name of the property or method to look for in the object.</description>
        </property>
        <property kind="example">
          <description>
            <![CDATA[ This method returns true of the specific object instance or prototype has a property or method with the name specified. The inheritance chain is not searched. The following example illustrates this:
function Person(){ ... }
Person.prototype.breathe=function(){ ... }
var fredAstaire = new Person();
fredAstaire.dance = function(){ ... }

if (Person.prototype.hasOwnProperty('breathe')){
        // this code will execute...the above call will return true
}
if (fredAstaire.hasOwnProperty('breathe')){
        // this code will NOT execute...
        // fredAstaire knows how to 'breathe', but this is an inherited method
}
if (fredAstaire.hasOwnProperty('dance')){
        // this code will execute...the above call will return true
}
if (Person.prototype.hasOwnProperty('dance')){
        // this code will NOT execute...
        // not every Person knows how to dance
}

]]>
</description>
        </property>
      </properties>
    </element>
    <element kind="function" name="Error_isPrototypeOf()">
      <note title="overview">Determines if the calling object prototype is in the inheritance chain for the supplied argument. Return Type: Boolean</note>
      <insert>isPrototypeOf(%_)</insert>
      <properties>
        <property kind="parameter" name="instanceToTest">
          <description>Object The object instance to check.</description>
        </property>
        <property kind="example">
          <description>
            <![CDATA[ The following code sample shows how to use this method to test if an object instance inherits from the calling prototype:
function Mammal(){ ... }
function Human(){ ... }
Human.prototype = new Mammal; //Human inherits from Mammal
var billGates = new Human();
if (Human.isPrototypeOf(billGates)){
        //this code will NOT run...
        //you must call this method on a prototype object
}
if (Human.prototype.isPrototypeOf(billGates)){
        //this code will run...the above will return true
}
if (Mammal.prototype.isPrototypeOf(billGates)){
        //this code will run...the above will return true
}
]]>
</description>
        </property>
      </properties>
    </element>
    <element kind="function" name="Error_propertyIsEnumerable()">
      <note title="overview">Determines if the object/instance itself has a property or method of the supplied name which will appear in a for (prop in obj) enumeration. Return Type: Boolean</note>
      <insert>propertyIsEnumerable(%_)</insert>
      <properties>
        <property kind="parameter" name="propertyOrMethodName">
          <description>String The name of the property or method to look for.</description>
        </property>
        <property kind="example">
          <description>
            <![CDATA[ This method does not search the inheritance chain of any instance supplied. Returns false if no property/method of the supplied name exists, or if one exists but will not appear during enumeration.

In general, built-in properties and methods are not enumerable, while user-defined properties and methods are.
]]>
</description>
        </property>
      </properties>
    </element>
    <element kind="function" name="Error_toLocaleString()">
      <note title="overview">For most objects, the same as toString() unless explicitly overridden. Return Type: String (this method takes no arguments)</note>
      <insert>toLocaleString()</insert>
      <properties>
        <property kind="example">
          <description>
            <![CDATA[ 
]]>
</description>
        </property>
      </properties>
    </element>
    <element kind="function" name="Error_toString()">
      <note title="overview">Returns a string representation of the object. Return Type: String (this method takes no arguments)</note>
      <insert>toString()</insert>
      <properties>
        <property kind="example">
          <description>
            <![CDATA[ For most objects, returns the string "[object "+className+"]". For internal objects, returns the following:ArrayEach member of the array has toString() called on it, and the results are joined together with commas. Equivalent to myArray.join().BooleanReturns "true" for true, "false" for false.DateThe format of the string value returned depends on the implementation. Often a human-readable string such as "Mon Nov 17 2003 13:56:48 GMT-0700"FunctionThe format of the string value returned depends on the implementation. Often a source-code representation of the function.NumberThe number converted to a string value. (See the specific entry for Number.toString(radix).)StringThe string's value.
</elem>]]>
</description>
        </property>
      </properties>
    </element>
    <element kind="function" name="Error_valueOf()">
      <note title="overview">Returns the internal this value of the object. Return Type: String (this method takes no arguments)</note>
      <insert>valueOf()</insert>
      <properties>
        <property kind="example">
          <description>
            <![CDATA[ For various intrinsic JS object types, this value returned is overridden and customized as follows:ArraySame as the Array.toString() method.Boolean(unchanged) The true/false value itself.DateA Number object with an integer value representing the time in milliseconds since Midnight, January 1st, 1970 UTC.Function(unchanged) A reference to the function object itself.Number(unchanged) The number value itself.Object(unchanged) A reference to the object itself.StringThe string's value.
]]>
</description>
        </property>
      </properties>
    </element>
  </group>
  <group name="Function">
    <note title="overview">The object representing functions and methods. Inherits from: Object</note>
    <element kind="var" name="Function_arguments">
      <note title="overview">An array of all parameters passed to the function/method. Property Type: Array</note>
      <properties>
        <property kind="example">
          <description>
            <![CDATA[ The arguments array is not actually a property of an instance of a Function object, but rather is created and made available to the function when it is called. This array is useful for determining how many of a function's declared parameters have been passed, or for accessing extra parameters which were not declared, but which were passed.

function AddThreeOrMore(){
    if (arguments.length<3) return null; // You must pass at least three numbers!
    var total=0;
    for (var i=0,len=arguments.length;i&amp;lt;len;i++) total += arguments[i]*1;
    return total;
}

var val = AddThreeOrMore(1,1);
// ** val is null, because not enough parameters were passed to the function

var val = AddThreeOrMore(1,1,1,1,1,1,1,1,1);
// ** val is 9

The arguments array also has a custom property named callee, which is a pointer to the current function being executed. This property allows a function to call itself without having to know its name or context:

function Factorial(n){
    if (Math.round(n)!=n || n<=0) return 0;
    if (n==1) return 1;
    return n * arguments.callee( n-1 );
}

var sixFactorial = Factorial(6);
// ** sixFactorial is 720
]]>
</description>
        </property>
      </properties>
      <insert>arguments</insert>
    </element>
    <element kind="var" name="Function_constructor">
      <note title="overview">A reference to the constructor class for the current object instance. Property Type: Object</note>
      <properties>
        <property kind="example">
          <description>
            <![CDATA[ Checking the constructor property for a custom object is a clean way to see its type. The following code takes objects of most any type and returns a string representation of them, suitable for use in source code. Note how the constructor property is used to check the object type of the parameter.

//For more information on this function, see http://phrogz.net/JS/Object.prototype.toSourceCode.js
Object.prototype.toSourceCode=function(hier,lv,forObj){
    var out,tabs='',idre=/^[a-z_][a-z0-9_]*$/i;
    if (!lv) lv=0;
    if (hier) tabs=Math.pow(10,lv).toString().substr(1).replace(/0/g,"\t");
    if (this.constructor==Array){
        out=(forObj?'':tabs)+'['+(hier?'\n':'');
        for (var i=0,len=this.length;i&amp;lt;len;i++){
            out+=((this[i]!=null)?this[i].toSourceCode(hier,lv+1):'null')
                +(i&amp;lt;(len-1)?',':'')+(hier?'\n':'');
        }
        return out+tabs+']';
    }else if(this.constructor==Object){
        out=(forObj?'':tabs)+'{'+(hier?'\n':'');
        for (var key in this){
            if (key!='toSourceCode'){
                out+=tabs+(hier?'\t':'')
                    +(idre.test(key)?key:("'"+key+"'"))
                    +":"+(this[key]==null?'null':this[key].toSourceCode(hier,lv+1,true))
                    +","+(hier?'\n':'');
            }
        }
        out=out.replace(/,(\n?)$/,'$1');
        return out+tabs+'}';
    }else if(this.constructor==String) return (forObj?'':tabs)+"'"+this+"'";
    else if(this.constructor==Date) return (forObj?'':tabs)+"new Date("+this.valueOf()+")";
    else return (forObj?'':tabs)+this.toString();
}

The constructor property is especially useful for distinguishing arrays from generic objects, since (per the spec) typeof(myArray) returns the string "object". The following example detects if the returned value is an array or not; if it's not, it is turned into a single-element array.

(In HTML, asking for a form element by name returns the element itself if only one named element exists, or returns an array of elements if more than one name exists. It is often convenient to treat both cases with the same code, which expects an array.)

var myForm=document.getElementById('myFormID');
var products = myForm.elements['product'];
if (products.constructor!=Array) products=[products];

The value of the constructor property is not limited to the built-in object types. The following example shows two custom classes, Mammal and Cat, where a method of the class detects the type of the instance.

function Mammal(name){
    this.name=name;
}
Mammal.prototype.toString=function(){
    if (this.constructor==Cat) return "[Cat '"+this.name+"']";
    else return "[Mammal '"+this.name+"']";
}

function Cat(name){
    this.name=name;
}
Cat.prototype=new Mammal;      //inherit from Mammal
Cat.prototype.constructor=Cat; //but keep the correct constructor

var bob = new Mammal('Bob');
var kitty = new Cat('Felix');

bob.toString();   //returns the string "[Mammal 'Bob']"
kitty.toString(); //returns the string "[Cat 'Felix']"
]]>
</description>
        </property>
      </properties>
      <insert>constructor</insert>
    </element>
    <element kind="var" name="Function_length">
      <note title="overview">The number of arguments declared with the function.
      <br />This property is read-only. Property Type: Number</note>
      <properties>
        <property kind="example">
          <description>
            <![CDATA[ This property is informative only, since calls to functions may choose to not pass parameters which are declared (in which case the parameters have a value of  undefined inside the function), or may choose to pass more parameters than are declared (which may be accessed through the arguments array inside the function).

function AddUpValues(){
    var total=0;
    for (var i=0,len=arguments.length;i&amp;lt;len;i++) total += arguments[ i ]*1;
    return total;
}

var sum = AddUpValues(1,2,3,4,5,6,7,8,9);
var len = AddUpValues.length;
// ** sum is 45
// ** len is 0

function SayHi(firstName,lastName){
    return "Hello "+firstName+" "+lastName;
}
var msg = SayHi();
var len = SayHi.length;
// ** msg is "Hello undefined undefined";
// ** len is 2
]]>
</description>
        </property>
      </properties>
      <insert>length</insert>
    </element>
    <element kind="var" name="Function_prototype">
      <note title="overview">The prototype for a class. Property Type: Object</note>
      <properties>
        <property kind="example">
          <description>
            <![CDATA[ This property is read-only for intrinsic JS classes (e.g. the Date object) but may be re-assigned for user-defined classes.

While the prototype property is 'read-only' for intrinsic classes, it may be used to extend their functionality. For example the following code uses the prototype property of the Number object to extend all numbers to support a custom 'truncate' method:

Number.prototype.trunctate=function(){
        return this>0?Math.floor(this):Math.ceil(this);
}
var x=12.37;
var y=-12.37;

x = x.truncate(); // ** 12
y = y.truncate(); // ** -12

The following code sample shows how to use the prototype property to cause one class to inherit from another:

function Mammal(name){ 
        this.name=name;
        this.offspring=[];
} 
Mammal.prototype.haveABaby=function(){ 
        var newBaby=new this.constructor("Baby "+this.name); //Uses Cat for cats, Mammal for Mammals
        this.offspring.push(newBaby);
        return newBaby;
} 
Mammal.prototype.toString=function(){ 
        return '[Mammal "'+this.name+'"]';
} 


Cat.prototype = new Mammal;          // Here's where the inheritance occurs 
Cat.prototype.constructor=Cat;       // Otherwise instances of Cat would have a constructor of Mammal 
function Cat(name){ 
        this.name=name;
} 
Cat.prototype.toString=function(){ 
        return '[Cat "'+this.name+'"]';
} 

var msg;

var someAnimal = new Mammal('Mr. Biggles');
msg = 'someAnimal is '+someAnimal;         // ** 'someAnimal is [Mammal "Mr. Biggles"]'

var myPet = new Cat('Felix');
msg = 'myPet is '+myPet;                   // ** 'myPet is [Cat "Felix"]' 

myPet.haveABaby();                         // calls a method inherited from Mammal 
msg = myPet.offspring.length;              // ** 1
msg = "First baby is "+myPet.offspring[0]; // ** 'First baby is [Cat "Baby Felix"]'
]]>
</description>
        </property>
      </properties>
      <insert>prototype</insert>
    </element>
    <element kind="function" name="Function_apply()">
      <note title="overview">Call the function/method, optionally setting a new scope for this and passing in parameters via an array. Return Type: Object</note>
      <insert>apply(%_)</insert>
      <properties>
        <property kind="parameter" name="thisScope">
          <description>Object [optional] The object to use as 
          <code>this</code>in the method. If omitted or 
          <code>null</code>, the global object is used as the current scope.</description>
        </property>
        <property kind="parameter" name="args">
          <description>Array [optional] An array of items to pass as arguments to the function.</description>
        </property>
        <property kind="example">
          <description>
            <![CDATA[ Like the call() method, this method of a function object allows you to invoke the function code, while specifying a different scope for it to run in. Unlike that method, parameters to be passed to the called function exist as a single array of parameters, not a comma-separated list.

In addition to the cases where call() is useful, this method allows you to create an arbitrary number of parameters to pass to the function via code. The following (contrived) example takes input from the user as long as it's not an empty string, and then calls a function which processes the arbitrary number of arguments passed to it.


function EnumerateParams(){
    var out='';
    for (var i=0,len=arguments.length;i&amp;lt;len;i++){
        out+="Parameter #"+i+" is '"+arguments[i]+"'\n";
    }
    return out;
}

var params = [];
var singleUserResponse;
while ( (singleUserResponse=GetUserInput()) != '' ){
    params.push( singleUserResponse );
}
var msg = EnumerateParams.apply(null,params);

The above sample code assumes a function called GetUserInput, which would be implementation-specific. To help illustrate the how the above would work, consider the following example:


var msg1 = EnumerateParams( 'alpha' , 'beta' , 'gamma' );

var msg2 = EnumerateParams.call( null , 'alpha' , 'beta' , 'gamma' );

var toPass = [ 'alpha' , 'beta' , 'gamma' ];
var msg3 = EnumerateParams.apply( null , toPass );
/***********************************************
msg1, msg2 and msg3 are all the same multiline string:
Parameter #0 is 'alpha'
Parameter #1 is 'beta'
Parameter #2 is 'gamma'
***********************************************/
]]>
</description>
        </property>
      </properties>
    </element>
    <element kind="function" name="Function_call()">
      <note title="overview">Call the function/method, optionally setting a new scope for this and passing in parameters. Return Type: Object</note>
      <insert>call(%_)</insert>
      <properties>
        <property kind="parameter" name="thisScope">
          <description>Object [optional] The object to use as 
          <code>this</code>in the method. If omitted, the global object is used as the current scope.</description>
        </property>
        <property kind="parameter" name="arg1">
          <description>Object [optional] The first argument to pass.</description>
        </property>
        <property kind="parameter" name="arg2">
          <description>Object [optional] The second argument to pass.</description>
        </property>
        <property kind="parameter" name="...">
          <description>Object [optional] etc.</description>
        </property>
        <property kind="example">
          <description>
            <![CDATA[ Like the apply method, this method of a function object allows you to invoke the function code, while specifying a different scope for it to run in. Unlike that method, parameters to be passed to the called function exist as a comma-separate list, not as an array of parameters.

A real-world example where this can be useful is to simulate multiple interfaces to a single class. (ECMAScript supports hierarchical inheritance amongst user-created classes, but does not allow a single class to inherit from multiple parents.) In the following example, the Rectangle class wants to be able to call methods from the Polygon class, but (for no reason other than to illustrate this method) does not inherit from that class.


function Polygon(){ }
Polygon.sweptVolume=function(sweepDistance){
    return this.calculateArea()*sweepDistance;
}

function Rectangle(width,length){
    this.width=width;
    this.length=length;
}
Rectangle.prototype.calculateArea=function(){
    return this.width*this.length;
}

var obj1 = new Rectangle(10,5);
var volume = Polygon.sweptVolume.call(obj1,4);
// ** volume is 200
]]>
</description>
        </property>
      </properties>
    </element>
    <element kind="function" name="Function_hasOwnProperty()">
      <note title="overview">Determines if the object/instance itself has the named property or method. Return Type: Boolean</note>
      <insert>hasOwnProperty(%_)</insert>
      <properties>
        <property kind="parameter" name="propertyOrMethodName">
          <description>String The name of the property or method to look for in the object.</description>
        </property>
        <property kind="example">
          <description>
            <![CDATA[ This method returns true of the specific object instance or prototype has a property or method with the name specified. The inheritance chain is not searched. The following example illustrates this:
function Person(){ ... }
Person.prototype.breathe=function(){ ... }
var fredAstaire = new Person();
fredAstaire.dance = function(){ ... }

if (Person.prototype.hasOwnProperty('breathe')){
        // this code will execute...the above call will return true
}
if (fredAstaire.hasOwnProperty('breathe')){
        // this code will NOT execute...
        // fredAstaire knows how to 'breathe', but this is an inherited method
}
if (fredAstaire.hasOwnProperty('dance')){
        // this code will execute...the above call will return true
}
if (Person.prototype.hasOwnProperty('dance')){
        // this code will NOT execute...
        // not every Person knows how to dance
}

]]>
</description>
        </property>
      </properties>
    </element>
    <element kind="function" name="Function_isPrototypeOf()">
      <note title="overview">Determines if the calling object prototype is in the inheritance chain for the supplied argument. Return Type: Boolean</note>
      <insert>isPrototypeOf(%_)</insert>
      <properties>
        <property kind="parameter" name="instanceToTest">
          <description>Object The object instance to check.</description>
        </property>
        <property kind="example">
          <description>
            <![CDATA[ The following code sample shows how to use this method to test if an object instance inherits from the calling prototype:
function Mammal(){ ... }
function Human(){ ... }
Human.prototype = new Mammal; //Human inherits from Mammal
var billGates = new Human();
if (Human.isPrototypeOf(billGates)){
        //this code will NOT run...
        //you must call this method on a prototype object
}
if (Human.prototype.isPrototypeOf(billGates)){
        //this code will run...the above will return true
}
if (Mammal.prototype.isPrototypeOf(billGates)){
        //this code will run...the above will return true
}
]]>
</description>
        </property>
      </properties>
    </element>
    <element kind="function" name="Function_propertyIsEnumerable()">
      <note title="overview">Determines if the object/instance itself has a property or method of the supplied name which will appear in a for (prop in obj) enumeration. Return Type: Boolean</note>
      <insert>propertyIsEnumerable(%_)</insert>
      <properties>
        <property kind="parameter" name="propertyOrMethodName">
          <description>String The name of the property or method to look for.</description>
        </property>
        <property kind="example">
          <description>
            <![CDATA[ This method does not search the inheritance chain of any instance supplied. Returns false if no property/method of the supplied name exists, or if one exists but will not appear during enumeration.

In general, built-in properties and methods are not enumerable, while user-defined properties and methods are.
]]>
</description>
        </property>
      </properties>
    </element>
    <element kind="function" name="Function_toLocaleString()">
      <note title="overview">For most objects, the same as toString() unless explicitly overridden. Return Type: String (this method takes no arguments)</note>
      <insert>toLocaleString()</insert>
      <properties>
        <property kind="example">
          <description>
            <![CDATA[ 
]]>
</description>
        </property>
      </properties>
    </element>
    <element kind="function" name="Function_toString()">
      <note title="overview">Returns a string representation of the object. Return Type: String (this method takes no arguments)</note>
      <insert>toString()</insert>
      <properties>
        <property kind="example">
          <description>
            <![CDATA[ For most objects, returns the string "[object "+className+"]". For internal objects, returns the following:ArrayEach member of the array has toString() called on it, and the results are joined together with commas. Equivalent to myArray.join().BooleanReturns "true" for true, "false" for false.DateThe format of the string value returned depends on the implementation. Often a human-readable string such as "Mon Nov 17 2003 13:56:48 GMT-0700"FunctionThe format of the string value returned depends on the implementation. Often a source-code representation of the function.NumberThe number converted to a string value. (See the specific entry for Number.toString(radix).)StringThe string's value.
</elem>]]>
</description>
        </property>
      </properties>
    </element>
    <element kind="function" name="Function_valueOf()">
      <note title="overview">Returns the internal this value of the object. Return Type: String (this method takes no arguments)</note>
      <insert>valueOf()</insert>
      <properties>
        <property kind="example">
          <description>
            <![CDATA[ For various intrinsic JS object types, this value returned is overridden and customized as follows:ArraySame as the Array.toString() method.Boolean(unchanged) The true/false value itself.DateA Number object with an integer value representing the time in milliseconds since Midnight, January 1st, 1970 UTC.Function(unchanged) A reference to the function object itself.Number(unchanged) The number value itself.Object(unchanged) A reference to the object itself.StringThe string's value.
]]>
</description>
        </property>
      </properties>
    </element>
  </group>
  <group name="Math">
    <note title="overview">A global, non-instantiable object which holds certain math-related functions and values. Inherits from: Object</note>
    <element kind="var" name="Math_constructor">
      <note title="overview">A reference to the constructor class for the current object instance. Property Type: Object</note>
      <properties>
        <property kind="example">
          <description>
            <![CDATA[ Checking the constructor property for a custom object is a clean way to see its type. The following code takes objects of most any type and returns a string representation of them, suitable for use in source code. Note how the constructor property is used to check the object type of the parameter.

//For more information on this function, see http://phrogz.net/JS/Object.prototype.toSourceCode.js
Object.prototype.toSourceCode=function(hier,lv,forObj){
    var out,tabs='',idre=/^[a-z_][a-z0-9_]*$/i;
    if (!lv) lv=0;
    if (hier) tabs=Math.pow(10,lv).toString().substr(1).replace(/0/g,"\t");
    if (this.constructor==Array){
        out=(forObj?'':tabs)+'['+(hier?'\n':'');
        for (var i=0,len=this.length;i&amp;lt;len;i++){
            out+=((this[i]!=null)?this[i].toSourceCode(hier,lv+1):'null')
                +(i&amp;lt;(len-1)?',':'')+(hier?'\n':'');
        }
        return out+tabs+']';
    }else if(this.constructor==Object){
        out=(forObj?'':tabs)+'{'+(hier?'\n':'');
        for (var key in this){
            if (key!='toSourceCode'){
                out+=tabs+(hier?'\t':'')
                    +(idre.test(key)?key:("'"+key+"'"))
                    +":"+(this[key]==null?'null':this[key].toSourceCode(hier,lv+1,true))
                    +","+(hier?'\n':'');
            }
        }
        out=out.replace(/,(\n?)$/,'$1');
        return out+tabs+'}';
    }else if(this.constructor==String) return (forObj?'':tabs)+"'"+this+"'";
    else if(this.constructor==Date) return (forObj?'':tabs)+"new Date("+this.valueOf()+")";
    else return (forObj?'':tabs)+this.toString();
}

The constructor property is especially useful for distinguishing arrays from generic objects, since (per the spec) typeof(myArray) returns the string "object". The following example detects if the returned value is an array or not; if it's not, it is turned into a single-element array.

(In HTML, asking for a form element by name returns the element itself if only one named element exists, or returns an array of elements if more than one name exists. It is often convenient to treat both cases with the same code, which expects an array.)

var myForm=document.getElementById('myFormID');
var products = myForm.elements['product'];
if (products.constructor!=Array) products=[products];

The value of the constructor property is not limited to the built-in object types. The following example shows two custom classes, Mammal and Cat, where a method of the class detects the type of the instance.

function Mammal(name){
    this.name=name;
}
Mammal.prototype.toString=function(){
    if (this.constructor==Cat) return "[Cat '"+this.name+"']";
    else return "[Mammal '"+this.name+"']";
}

function Cat(name){
    this.name=name;
}
Cat.prototype=new Mammal;      //inherit from Mammal
Cat.prototype.constructor=Cat; //but keep the correct constructor

var bob = new Mammal('Bob');
var kitty = new Cat('Felix');

bob.toString();   //returns the string "[Mammal 'Bob']"
kitty.toString(); //returns the string "[Cat 'Felix']"
]]>
</description>
        </property>
      </properties>
      <insert>constructor</insert>
    </element>
    <element kind="var" name="Math_prototype">
      <note title="overview">The prototype for a class. Property Type: Object</note>
      <properties>
        <property kind="example">
          <description>
            <![CDATA[ This property is read-only for intrinsic JS classes (e.g. the Date object) but may be re-assigned for user-defined classes.

While the prototype property is 'read-only' for intrinsic classes, it may be used to extend their functionality. For example the following code uses the prototype property of the Number object to extend all numbers to support a custom 'truncate' method:

Number.prototype.trunctate=function(){
        return this>0?Math.floor(this):Math.ceil(this);
}
var x=12.37;
var y=-12.37;

x = x.truncate(); // ** 12
y = y.truncate(); // ** -12

The following code sample shows how to use the prototype property to cause one class to inherit from another:

function Mammal(name){ 
        this.name=name;
        this.offspring=[];
} 
Mammal.prototype.haveABaby=function(){ 
        var newBaby=new this.constructor("Baby "+this.name); //Uses Cat for cats, Mammal for Mammals
        this.offspring.push(newBaby);
        return newBaby;
} 
Mammal.prototype.toString=function(){ 
        return '[Mammal "'+this.name+'"]';
} 


Cat.prototype = new Mammal;          // Here's where the inheritance occurs 
Cat.prototype.constructor=Cat;       // Otherwise instances of Cat would have a constructor of Mammal 
function Cat(name){ 
        this.name=name;
} 
Cat.prototype.toString=function(){ 
        return '[Cat "'+this.name+'"]';
} 

var msg;

var someAnimal = new Mammal('Mr. Biggles');
msg = 'someAnimal is '+someAnimal;         // ** 'someAnimal is [Mammal "Mr. Biggles"]'

var myPet = new Cat('Felix');
msg = 'myPet is '+myPet;                   // ** 'myPet is [Cat "Felix"]' 

myPet.haveABaby();                         // calls a method inherited from Mammal 
msg = myPet.offspring.length;              // ** 1
msg = "First baby is "+myPet.offspring[0]; // ** 'First baby is [Cat "Baby Felix"]'
]]>
</description>
        </property>
      </properties>
      <insert>prototype</insert>
    </element>
    <element kind="function" name="Math_abs()">
      <note title="overview">Return the absolute value of x. Return Type: Number</note>
      <insert>abs(%_)</insert>
      <properties>
        <property kind="parameter" name="x">
          <description>Number The value to operate upon.</description>
        </property>
        <property kind="example">
          <description>
            <![CDATA[ 
]]>
</description>
        </property>
      </properties>
    </element>
    <element kind="function" name="Math_acos()">
      <note title="overview">Return the arc cosine of x, in radians. Return Type: Number</note>
      <insert>acos(%_)</insert>
      <properties>
        <property kind="parameter" name="x">
          <description>Number The value to operate upon.</description>
        </property>
        <property kind="example">
          <description>
            <![CDATA[ 
]]>
</description>
        </property>
      </properties>
    </element>
    <element kind="function" name="Math_atan()">
      <note title="overview">Return the arc tangent of x, in radians. Return Type: Number</note>
      <insert>atan(%_)</insert>
      <properties>
        <property kind="parameter" name="x">
          <description>Number The value to operate upon.</description>
        </property>
        <property kind="example">
          <description>
            <![CDATA[ 
]]>
</description>
        </property>
      </properties>
    </element>
    <element kind="function" name="Math_atan()">
      <note title="overview">Return the arc tangent of x, in radians. Return Type: Number</note>
      <insert>atan(%_)</insert>
      <properties>
        <property kind="parameter" name="x">
          <description>Number The value to operate upon.</description>
        </property>
        <property kind="example">
          <description>
            <![CDATA[ 
]]>
</description>
        </property>
      </properties>
    </element>
    <element kind="function" name="Math_ceil()">
      <note title="overview">Return smallest integer which is larger than x (aka "round up"). Return Type: Number</note>
      <insert>ceil(%_)</insert>
      <properties>
        <property kind="parameter" name="x">
          <description>Number The value to operate upon.</description>
        </property>
        <property kind="example">
          <description>
            <![CDATA[ var x = Math.ceil(12.432);
// ** x is 13

var y = Math.ceil(-12.432);
// ** y is -12

var z = Math.ceil(1);
// ** z is 1
]]>
</description>
        </property>
      </properties>
    </element>
    <element kind="function" name="Math_cos()">
      <note title="overview">Return the cosine of x, in radians. Return Type: Number</note>
      <insert>cos(%_)</insert>
      <properties>
        <property kind="parameter" name="x">
          <description>Number The value to operate upon.</description>
        </property>
        <property kind="example">
          <description>
            <![CDATA[ 
]]>
</description>
        </property>
      </properties>
    </element>
    <element kind="function" name="Math_exp()">
      <note title="overview">Return the value of 
      <i>e</i>
      <sup>x</sup>. Return Type: Number</note>
      <insert>exp(%_)</insert>
      <properties>
        <property kind="parameter" name="x">
          <description>Number The value to operate upon.</description>
        </property>
        <property kind="example">
          <description>
            <![CDATA[ 
]]>
</description>
        </property>
      </properties>
    </element>
    <element kind="function" name="Math_floor()">
      <note title="overview">Return largest integer which is less than x (aka "round down"). Return Type: Number</note>
      <insert>floor(%_)</insert>
      <properties>
        <property kind="parameter" name="x">
          <description>Number The value to operate upon.</description>
        </property>
        <property kind="example">
          <description>
            <![CDATA[ var x = Math.floor(12.832);
// ** x is 12

var y = Math.floor(-12.832);
// ** y is -13

var z = Math.floor(1);
// ** z is 1
]]>
</description>
        </property>
      </properties>
    </element>
    <element kind="function" name="Math_log()">
      <note title="overview">Return the natural logarithm of x. Return Type: Number</note>
      <insert>log(%_)</insert>
      <properties>
        <property kind="parameter" name="x">
          <description>Number The value to operate upon.</description>
        </property>
        <property kind="example">
          <description>
            <![CDATA[ This function returns the natural logarithm of the argument; <em>i.e.</em> the log-base-<i>e</i>. Put another way, Math.pow(Math.E , Math.log( n ) ) == n. (Or more simply, Math.exp( Math.log(n) ) == n.)

To get the log-base-10 value of a number, use the fact that log-base-t( x ) == log-base-<i>e</i>(x) / log-base-<i>e</i>(t).

The following code will provide the Math class with a new convenience function for log-base-10:

Math.log10=function(x){ return Math.log(x)/Math.LN10 }

Or, for a more general case:

Math.logN=function(n,x){ return Math.log(x)/Math.log(n) }
]]>
</description>
        </property>
      </properties>
    </element>
    <element kind="function" name="Math_max()">
      <note title="overview">Return the largest of all arguments supplied. Return Type: Number</note>
      <insert>max(%_)</insert>
      <properties>
        <property kind="parameter" name="value1">
          <description>Number [optional] The first value.</description>
        </property>
        <property kind="parameter" name="value2">
          <description>Number [optional] The second value.</description>
        </property>
        <property kind="parameter" name="...">
          <description>Number [optional] etc.</description>
        </property>
        <property kind="example">
          <description>
            <![CDATA[ If any of the arguments are not numbers, an attempt is made to convert them to numbers. If this attempt fails, the result will be NaN.

var biggest = Math.max( 1 , 17 , '5', -0.4 , 18 , 3.1 );
// ** biggest is 18

var failedAttempt = Math.max( 10 , 'bee' );
// ** failedAttempt is NaN

If no arguments are supplied, the return value is Math.NEGATIVE_INFINITY.
]]>
</description>
        </property>
      </properties>
    </element>
    <element kind="function" name="Math_min()">
      <note title="overview">Return the smallest of all arguments supplied. Return Type: Number</note>
      <insert>min(%_)</insert>
      <properties>
        <property kind="parameter" name="value1">
          <description>Number [optional] The first value.</description>
        </property>
        <property kind="parameter" name="value2">
          <description>Number [optional] The second value.</description>
        </property>
        <property kind="parameter" name="...">
          <description>Number [optional] etc.</description>
        </property>
        <property kind="example">
          <description>
            <![CDATA[ If any of the arguments are not numbers, an attempt is made to convert them to numbers. If this attempt fails, the result will be NaN.

var smallest = Math.min( 1 , 17 , '5', -0.4 , 18 , 3.1 );
// ** smallest is -0.4

var failedAttempt = Math.min( 10 , 'bee' );
// ** failedAttempt is NaN

If no arguments are supplied, the return value is Math.POSITIVE_INFINITY.
]]>
</description>
        </property>
      </properties>
    </element>
    <element kind="function" name="Math_pow()">
      <note title="overview">Return the value of raising x to the power y. Return Type: Number</note>
      <insert>pow(%_)</insert>
      <properties>
        <property kind="parameter" name="x">
          <description>Number The base of the exponential expression.</description>
        </property>
        <property kind="parameter" name="y">
          <description>Number The exponent of the expression.</description>
        </property>
        <property kind="example">
          <description>
            <![CDATA[ 
]]>
</description>
        </property>
      </properties>
    </element>
    <element kind="function" name="Math_random()">
      <note title="overview">Return a floating-point random number between 0 (inclusive) and 1 (exclusive). Return Type: Number (this method takes no arguments)</note>
      <insert>random()</insert>
      <properties>
        <property kind="example">
          <description>
            <![CDATA[ The following code sample shows a convenience method which extends the Math object to support an addition method, allowing the caller to specify minimum and maximum values, and to specify if the result should be an integer or a floating point number:
Math.randomValue = function (min,max,asFloat){
    var r = Math.random()*(max-min)+min;
    return asFloat?r:Math.round(r);
}

var percentChance = Math.randomValue(0,100,true); // e.g. 98.76234112334
var fromOneToTen = Math.randomValue(1,10); // e.g. 8


Math.random() will never return 1, but Math.round() is called on the result for integer values; as such, percentChance might be 99.9999 but it will never be 100, whereas fromOneToTen might easily be 10.
]]>
</description>
        </property>
      </properties>
    </element>
    <element kind="function" name="Math_round()">
      <note title="overview">Round a number to the closest integer. Return Type: Number</note>
      <insert>round(%_)</insert>
      <properties>
        <property kind="parameter" name="x">
          <description>Number The value to operate upon.</description>
        </property>
        <property kind="example">
          <description>
            <![CDATA[ This method always rounds the number to the nearest integer. To round a number to a specified number of decimal places (for formatting, such as displaying currency), use the Number.toFixed() method. Alternatively, you may use a hack like:
var x = 16.457221;
x = Math.round( x * 100 ) / 100;
// ** x is close to 16.46

...but as noted above, the value may not always be exactly what you want. The above, for example, might display as 16.45999999999 due to the limitation of representing floating point numbers as a fixed number of binary digits. When dealing with fixed precision amounts like currency, its best to track all values as integers (e.g. the number cents, rather than dollars) and convert to decimal using toFixed() for display purposes only.

(An actual example of the problem is that 0.06 + 0.01 will produce the value 0.069999999999999 rather than 0.07.)
]]>
</description>
        </property>
      </properties>
    </element>
    <element kind="function" name="Math_sin()">
      <note title="overview">Return the sine of x, in radians. Return Type: Number</note>
      <insert>sin(%_)</insert>
      <properties>
        <property kind="parameter" name="x">
          <description>Number The value to operate upon.</description>
        </property>
        <property kind="example">
          <description>
            <![CDATA[ 
]]>
</description>
        </property>
      </properties>
    </element>
    <element kind="function" name="Math_sqrt()">
      <note title="overview">Return the square root of x. Return Type: Number</note>
      <insert>sqrt(%_)</insert>
      <properties>
        <property kind="parameter" name="x">
          <description>Number The value to operate upon.</description>
        </property>
        <property kind="example">
          <description>
            <![CDATA[ 
]]>
</description>
        </property>
      </properties>
    </element>
    <element kind="function" name="Math_tan()">
      <note title="overview">Return the tangent of x, in radians. Return Type: Number</note>
      <insert>tan(%_)</insert>
      <properties>
        <property kind="parameter" name="x">
          <description>Number The value to operate upon.</description>
        </property>
        <property kind="example">
          <description>
            <![CDATA[ 
]]>
</description>
        </property>
      </properties>
    </element>
    <element kind="function" name="Math_hasOwnProperty()">
      <note title="overview">Determines if the object/instance itself has the named property or method. Return Type: Boolean</note>
      <insert>hasOwnProperty(%_)</insert>
      <properties>
        <property kind="parameter" name="propertyOrMethodName">
          <description>String The name of the property or method to look for in the object.</description>
        </property>
        <property kind="example">
          <description>
            <![CDATA[ This method returns true of the specific object instance or prototype has a property or method with the name specified. The inheritance chain is not searched. The following example illustrates this:
function Person(){ ... }
Person.prototype.breathe=function(){ ... }
var fredAstaire = new Person();
fredAstaire.dance = function(){ ... }

if (Person.prototype.hasOwnProperty('breathe')){
        // this code will execute...the above call will return true
}
if (fredAstaire.hasOwnProperty('breathe')){
        // this code will NOT execute...
        // fredAstaire knows how to 'breathe', but this is an inherited method
}
if (fredAstaire.hasOwnProperty('dance')){
        // this code will execute...the above call will return true
}
if (Person.prototype.hasOwnProperty('dance')){
        // this code will NOT execute...
        // not every Person knows how to dance
}

]]>
</description>
        </property>
      </properties>
    </element>
    <element kind="function" name="Math_isPrototypeOf()">
      <note title="overview">Determines if the calling object prototype is in the inheritance chain for the supplied argument. Return Type: Boolean</note>
      <insert>isPrototypeOf(%_)</insert>
      <properties>
        <property kind="parameter" name="instanceToTest">
          <description>Object The object instance to check.</description>
        </property>
        <property kind="example">
          <description>
            <![CDATA[ The following code sample shows how to use this method to test if an object instance inherits from the calling prototype:
function Mammal(){ ... }
function Human(){ ... }
Human.prototype = new Mammal; //Human inherits from Mammal
var billGates = new Human();
if (Human.isPrototypeOf(billGates)){
        //this code will NOT run...
        //you must call this method on a prototype object
}
if (Human.prototype.isPrototypeOf(billGates)){
        //this code will run...the above will return true
}
if (Mammal.prototype.isPrototypeOf(billGates)){
        //this code will run...the above will return true
}
]]>
</description>
        </property>
      </properties>
    </element>
    <element kind="function" name="Math_propertyIsEnumerable()">
      <note title="overview">Determines if the object/instance itself has a property or method of the supplied name which will appear in a for (prop in obj) enumeration. Return Type: Boolean</note>
      <insert>propertyIsEnumerable(%_)</insert>
      <properties>
        <property kind="parameter" name="propertyOrMethodName">
          <description>String The name of the property or method to look for.</description>
        </property>
        <property kind="example">
          <description>
            <![CDATA[ This method does not search the inheritance chain of any instance supplied. Returns false if no property/method of the supplied name exists, or if one exists but will not appear during enumeration.

In general, built-in properties and methods are not enumerable, while user-defined properties and methods are.
]]>
</description>
        </property>
      </properties>
    </element>
    <element kind="function" name="Math_toLocaleString()">
      <note title="overview">For most objects, the same as toString() unless explicitly overridden. Return Type: String (this method takes no arguments)</note>
      <insert>toLocaleString()</insert>
      <properties>
        <property kind="example">
          <description>
            <![CDATA[ 
]]>
</description>
        </property>
      </properties>
    </element>
    <element kind="function" name="Math_toString()">
      <note title="overview">Returns a string representation of the object. Return Type: String (this method takes no arguments)</note>
      <insert>toString()</insert>
      <properties>
        <property kind="example">
          <description>
            <![CDATA[ For most objects, returns the string "[object "+className+"]". For internal objects, returns the following:ArrayEach member of the array has toString() called on it, and the results are joined together with commas. Equivalent to myArray.join().BooleanReturns "true" for true, "false" for false.DateThe format of the string value returned depends on the implementation. Often a human-readable string such as "Mon Nov 17 2003 13:56:48 GMT-0700"FunctionThe format of the string value returned depends on the implementation. Often a source-code representation of the function.NumberThe number converted to a string value. (See the specific entry for Number.toString(radix).)StringThe string's value.
</elem>]]>
</description>
        </property>
      </properties>
    </element>
    <element kind="function" name="Math_valueOf()">
      <note title="overview">Returns the internal this value of the object. Return Type: String (this method takes no arguments)</note>
      <insert>valueOf()</insert>
      <properties>
        <property kind="example">
          <description>
            <![CDATA[ For various intrinsic JS object types, this value returned is overridden and customized as follows:ArraySame as the Array.toString() method.Boolean(unchanged) The true/false value itself.DateA Number object with an integer value representing the time in milliseconds since Midnight, January 1st, 1970 UTC.Function(unchanged) A reference to the function object itself.Number(unchanged) The number value itself.Object(unchanged) A reference to the object itself.StringThe string's value.
]]>
</description>
        </property>
      </properties>
    </element>
  </group>
  <group name="Number">
    <note title="overview">Basic object. Inherits from: Object</note>
    <element kind="var" name="Number_constructor">
      <note title="overview">A reference to the constructor class for the current object instance. Property Type: Object</note>
      <properties>
        <property kind="example">
          <description>
            <![CDATA[ Checking the constructor property for a custom object is a clean way to see its type. The following code takes objects of most any type and returns a string representation of them, suitable for use in source code. Note how the constructor property is used to check the object type of the parameter.

//For more information on this function, see http://phrogz.net/JS/Object.prototype.toSourceCode.js
Object.prototype.toSourceCode=function(hier,lv,forObj){
    var out,tabs='',idre=/^[a-z_][a-z0-9_]*$/i;
    if (!lv) lv=0;
    if (hier) tabs=Math.pow(10,lv).toString().substr(1).replace(/0/g,"\t");
    if (this.constructor==Array){
        out=(forObj?'':tabs)+'['+(hier?'\n':'');
        for (var i=0,len=this.length;i&amp;lt;len;i++){
            out+=((this[i]!=null)?this[i].toSourceCode(hier,lv+1):'null')
                +(i&amp;lt;(len-1)?',':'')+(hier?'\n':'');
        }
        return out+tabs+']';
    }else if(this.constructor==Object){
        out=(forObj?'':tabs)+'{'+(hier?'\n':'');
        for (var key in this){
            if (key!='toSourceCode'){
                out+=tabs+(hier?'\t':'')
                    +(idre.test(key)?key:("'"+key+"'"))
                    +":"+(this[key]==null?'null':this[key].toSourceCode(hier,lv+1,true))
                    +","+(hier?'\n':'');
            }
        }
        out=out.replace(/,(\n?)$/,'$1');
        return out+tabs+'}';
    }else if(this.constructor==String) return (forObj?'':tabs)+"'"+this+"'";
    else if(this.constructor==Date) return (forObj?'':tabs)+"new Date("+this.valueOf()+")";
    else return (forObj?'':tabs)+this.toString();
}

The constructor property is especially useful for distinguishing arrays from generic objects, since (per the spec) typeof(myArray) returns the string "object". The following example detects if the returned value is an array or not; if it's not, it is turned into a single-element array.

(In HTML, asking for a form element by name returns the element itself if only one named element exists, or returns an array of elements if more than one name exists. It is often convenient to treat both cases with the same code, which expects an array.)

var myForm=document.getElementById('myFormID');
var products = myForm.elements['product'];
if (products.constructor!=Array) products=[products];

The value of the constructor property is not limited to the built-in object types. The following example shows two custom classes, Mammal and Cat, where a method of the class detects the type of the instance.

function Mammal(name){
    this.name=name;
}
Mammal.prototype.toString=function(){
    if (this.constructor==Cat) return "[Cat '"+this.name+"']";
    else return "[Mammal '"+this.name+"']";
}

function Cat(name){
    this.name=name;
}
Cat.prototype=new Mammal;      //inherit from Mammal
Cat.prototype.constructor=Cat; //but keep the correct constructor

var bob = new Mammal('Bob');
var kitty = new Cat('Felix');

bob.toString();   //returns the string "[Mammal 'Bob']"
kitty.toString(); //returns the string "[Cat 'Felix']"
]]>
</description>
        </property>
      </properties>
      <insert>constructor</insert>
    </element>
    <element kind="var" name="Number_prototype">
      <note title="overview">The prototype for a class. Property Type: Object</note>
      <properties>
        <property kind="example">
          <description>
            <![CDATA[ This property is read-only for intrinsic JS classes (e.g. the Date object) but may be re-assigned for user-defined classes.

While the prototype property is 'read-only' for intrinsic classes, it may be used to extend their functionality. For example the following code uses the prototype property of the Number object to extend all numbers to support a custom 'truncate' method:

Number.prototype.trunctate=function(){
        return this>0?Math.floor(this):Math.ceil(this);
}
var x=12.37;
var y=-12.37;

x = x.truncate(); // ** 12
y = y.truncate(); // ** -12

The following code sample shows how to use the prototype property to cause one class to inherit from another:

function Mammal(name){ 
        this.name=name;
        this.offspring=[];
} 
Mammal.prototype.haveABaby=function(){ 
        var newBaby=new this.constructor("Baby "+this.name); //Uses Cat for cats, Mammal for Mammals
        this.offspring.push(newBaby);
        return newBaby;
} 
Mammal.prototype.toString=function(){ 
        return '[Mammal "'+this.name+'"]';
} 


Cat.prototype = new Mammal;          // Here's where the inheritance occurs 
Cat.prototype.constructor=Cat;       // Otherwise instances of Cat would have a constructor of Mammal 
function Cat(name){ 
        this.name=name;
} 
Cat.prototype.toString=function(){ 
        return '[Cat "'+this.name+'"]';
} 

var msg;

var someAnimal = new Mammal('Mr. Biggles');
msg = 'someAnimal is '+someAnimal;         // ** 'someAnimal is [Mammal "Mr. Biggles"]'

var myPet = new Cat('Felix');
msg = 'myPet is '+myPet;                   // ** 'myPet is [Cat "Felix"]' 

myPet.haveABaby();                         // calls a method inherited from Mammal 
msg = myPet.offspring.length;              // ** 1
msg = "First baby is "+myPet.offspring[0]; // ** 'First baby is [Cat "Baby Felix"]'
]]>
</description>
        </property>
      </properties>
      <insert>prototype</insert>
    </element>
    <element kind="function" name="Number_hasOwnProperty()">
      <note title="overview">Determines if the object/instance itself has the named property or method. Return Type: Boolean</note>
      <insert>hasOwnProperty(%_)</insert>
      <properties>
        <property kind="parameter" name="propertyOrMethodName">
          <description>String The name of the property or method to look for in the object.</description>
        </property>
        <property kind="example">
          <description>
            <![CDATA[ This method returns true of the specific object instance or prototype has a property or method with the name specified. The inheritance chain is not searched. The following example illustrates this:
function Person(){ ... }
Person.prototype.breathe=function(){ ... }
var fredAstaire = new Person();
fredAstaire.dance = function(){ ... }

if (Person.prototype.hasOwnProperty('breathe')){
        // this code will execute...the above call will return true
}
if (fredAstaire.hasOwnProperty('breathe')){
        // this code will NOT execute...
        // fredAstaire knows how to 'breathe', but this is an inherited method
}
if (fredAstaire.hasOwnProperty('dance')){
        // this code will execute...the above call will return true
}
if (Person.prototype.hasOwnProperty('dance')){
        // this code will NOT execute...
        // not every Person knows how to dance
}

]]>
</description>
        </property>
      </properties>
    </element>
    <element kind="function" name="Number_isPrototypeOf()">
      <note title="overview">Determines if the calling object prototype is in the inheritance chain for the supplied argument. Return Type: Boolean</note>
      <insert>isPrototypeOf(%_)</insert>
      <properties>
        <property kind="parameter" name="instanceToTest">
          <description>Object The object instance to check.</description>
        </property>
        <property kind="example">
          <description>
            <![CDATA[ The following code sample shows how to use this method to test if an object instance inherits from the calling prototype:
function Mammal(){ ... }
function Human(){ ... }
Human.prototype = new Mammal; //Human inherits from Mammal
var billGates = new Human();
if (Human.isPrototypeOf(billGates)){
        //this code will NOT run...
        //you must call this method on a prototype object
}
if (Human.prototype.isPrototypeOf(billGates)){
        //this code will run...the above will return true
}
if (Mammal.prototype.isPrototypeOf(billGates)){
        //this code will run...the above will return true
}
]]>
</description>
        </property>
      </properties>
    </element>
    <element kind="function" name="Number_propertyIsEnumerable()">
      <note title="overview">Determines if the object/instance itself has a property or method of the supplied name which will appear in a for (prop in obj) enumeration. Return Type: Boolean</note>
      <insert>propertyIsEnumerable(%_)</insert>
      <properties>
        <property kind="parameter" name="propertyOrMethodName">
          <description>String The name of the property or method to look for.</description>
        </property>
        <property kind="example">
          <description>
            <![CDATA[ This method does not search the inheritance chain of any instance supplied. Returns false if no property/method of the supplied name exists, or if one exists but will not appear during enumeration.

In general, built-in properties and methods are not enumerable, while user-defined properties and methods are.
]]>
</description>
        </property>
      </properties>
    </element>
    <element kind="function" name="Number_toExponential()">
      <note title="overview">Return the number formatted in scientific notation, with one digit before the decimal point and a specified number of digits after. Return Type: String</note>
      <insert>toExponential(%_)</insert>
      <properties>
        <property kind="parameter" name="fractionDigits">
          <description>Number [optional] The number of digits which should follow the decimal point.</description>
        </property>
        <property kind="example">
          <description>
            <![CDATA[ If fractionDigits is omitted, the number of digits following the decimal point will vary, showing only enough needed to uniquely identify the number.
var precision = [0,1,2,3];
var numbers = [ 0 , 0.567 , 1.5 , -0.07 , 873];
var msg="";
for (var i=0,len=numbers.length;i&amp;lt;len;i++){
    var n = numbers[i];
    msg += "("+n+").toExponential() is '"+n.toExponential()+"'\n";
    for (var j=0,len2=precision.length;j&amp;lt;len2;j++){
        var digits = precision[j];
        msg += "("+n+").toExponential("+digits+") is '"+n.toExponential(digits)+"'\n";
    }
}
/***********************************
msg is
(0).toExponential() is '0e+0'
(0).toExponential(0) is '0e+0'
(0).toExponential(1) is '0.0e+0'
(0).toExponential(2) is '0.00e+0'
(0).toExponential(3) is '0.000e+0'
(0.567).toExponential() is '5.67e-1'
(0.567).toExponential(0) is '6e-1'
(0.567).toExponential(1) is '5.7e-1'
(0.567).toExponential(2) is '5.67e-1'
(0.567).toExponential(3) is '5.670e-1'
(1.5).toExponential() is '1.5e+0'
(1.5).toExponential(0) is '2e+0'
(1.5).toExponential(1) is '1.5e+0'
(1.5).toExponential(2) is '1.50e+0'
(1.5).toExponential(3) is '1.500e+0'
(-0.07).toExponential() is '-7e-2'
(-0.07).toExponential(0) is '-7e-2'
(-0.07).toExponential(1) is '-7.0e-2'
(-0.07).toExponential(2) is '-7.00e-2'
(-0.07).toExponential(3) is '-7.000e-2'
(873).toExponential() is '8.73e+2'
(873).toExponential(0) is '9e+2'
(873).toExponential(1) is '8.7e+2'
(873).toExponential(2) is '8.73e+2'
(873).toExponential(3) is '8.730e+2'
***********************************/
]]>
</description>
        </property>
      </properties>
    </element>
    <element kind="function" name="Number_toFixed()">
      <note title="overview">Return the number formatted with a specified number of digits after the decimal point. Return Type: String</note>
      <insert>toFixed(%_)</insert>
      <properties>
        <property kind="parameter" name="fractionDigits">
          <description>Number [optional] The number of digits which should follow the decimal point.</description>
        </property>
        <property kind="example">
          <description>
            <![CDATA[ If fractionDigits is omitted, 0 is assumed (the same as Math.round(myNumber).toString()).
var precision = [0,1,2,3];
var numbers = [ 0 , 0.567 , 1.5 , -0.07 ];
var msg="";
for (var i=0,len=numbers.length;i&amp;lt;len;i++){
    var n = numbers[i];
    for (var j=0,len2=precision.length;j&amp;lt;len2;j++){
        var digits = precision[j];
        msg += "("+n+").toFixed("+digits+") is '"+n.toFixed(digits)+"'\n";
    }
}
/*********************************
msg is:
(0).toFixed(0) is '0'
(0).toFixed(1) is '0.0'
(0).toFixed(2) is '0.00'
(0).toFixed(3) is '0.000'
(0.567).toFixed(0) is '1'
(0.567).toFixed(1) is '0.6'
(0.567).toFixed(2) is '0.57'
(0.567).toFixed(3) is '0.567'
(1.5).toFixed(0) is '2'
(1.5).toFixed(1) is '1.5'
(1.5).toFixed(2) is '1.50'
(1.5).toFixed(3) is '1.500'
(-0.07).toFixed(0) is '-0'
(-0.07).toFixed(1) is '-0.1'
(-0.07).toFixed(2) is '-0.07'
(-0.07).toFixed(3) is '-0.070'
*********************************/
]]>
</description>
        </property>
      </properties>
    </element>
    <element kind="function" name="Number_toLocaleString()">
      <note title="overview">For most objects, the same as toString() unless explicitly overridden. Return Type: String (this method takes no arguments)</note>
      <insert>toLocaleString()</insert>
      <properties>
        <property kind="example">
          <description>
            <![CDATA[ 
]]>
</description>
        </property>
      </properties>
    </element>
    <element kind="function" name="Number_toPrecision()">
      <note title="overview">Return the number as a string in either in fixed or exponential notation, with the specified number of digits. Return Type: String</note>
      <insert>toPrecision(%_)</insert>
      <properties>
        <property kind="parameter" name="precision">
          <description>Number The amount of precision which should be expressed.</description>
        </property>
        <property kind="example">
          <description>
            <![CDATA[ By default, the specs require precision to be between 1 and 21 (inclusive). If it is outside this range, an error will be generated. However, specific implementations may extend this range further.

If precision is omitted, toString() is called instead.
var precision = [1,2,3,4];
var numbers = [ 0 , 1.5 , 873 , 10230];
var msg="";
for (var i=0,len=numbers.length;i&amp;lt;en;i++){
    var n = numbers[i];
    for (var j=0,len2=precision.length;j&amp;lt;len2;j++){
        var digits = precision[j];
        msg += "("+n+").toPrecision("+digits+") is '"+n.toPrecision(digits)+"'\n";
    }
}
/**************************
msg is
(0).toPrecision(1) is '0'
(0).toPrecision(2) is '0.0'
(0).toPrecision(3) is '0.00'
(0).toPrecision(4) is '0.000'
(1.5).toPrecision(1) is '2'
(1.5).toPrecision(2) is '1.5'
(1.5).toPrecision(3) is '1.50'
(1.5).toPrecision(4) is '1.500'
(873).toPrecision(1) is '9e+2'
(873).toPrecision(2) is '8.7e+2'
(873).toPrecision(3) is '873'
(873).toPrecision(4) is '873.0'
(10230).toPrecision(1) is '1e+4'
(10230).toPrecision(2) is '1.0e+4'
(10230).toPrecision(3) is '1.02e+4'
(10230).toPrecision(4) is '1.023e+4'
**************************/
]]>
</description>
        </property>
      </properties>
    </element>
    <element kind="function" name="Number_toString()">
      <note title="overview">Return the number as a string converted to a specified base. Return Type: String</note>
      <insert>toString(%_)</insert>
      <properties>
        <property kind="parameter" name="radix">
          <description>Number [optional] The base to express the number in.</description>
        </property>
        <property kind="example">
          <description>
            <![CDATA[ If radix is undefined, base 10 is assumed. The following code shows this method being used to express numbers in various bases:var numbers = [8,10,12,16,200,255];
var bases = [2,8,10,16];
var msg="";
for (var i=0,len=numbers.length;i&amp;lt;len;i++){
    var n = numbers[i];
    for (var j=0,len2=bases.length;j&amp;lt;len2;j++){
        var base = bases[j];
        msg += n+' in base '+base+' is '+n.toString(base)+'\n';
    }
}
/****************************************
msg is:
8 in base 2 is 1000
8 in base 8 is 10
8 in base 10 is 8
8 in base 16 is 8
10 in base 2 is 1010
10 in base 8 is 12
10 in base 10 is 10
10 in base 16 is a
12 in base 2 is 1100
12 in base 8 is 14
12 in base 10 is 12
12 in base 16 is c
16 in base 2 is 10000
16 in base 8 is 20
16 in base 10 is 16
16 in base 16 is 10
200 in base 2 is 11001000
200 in base 8 is 310
200 in base 10 is 200
200 in base 16 is c8
255 in base 2 is 11111111
255 in base 8 is 377
255 in base 10 is 255
255 in base 16 is ff
****************************************/

Note that the returned string is not padded to any number of digits. The following convenience method shows how to extend the Number prototype to support a new method, which allows you to specify a certain number of digits desired; if less than that number is returned by the call to toString(), 0s are padded to the front.

Number.prototype.convertTo=function(base,padTo){
    var s=this.toString(base);
    if (!padTo || s.length>=padTo) return s;
    return Math.pow(10,padTo-s.length).toString().slice(1)+s;
}
var x = 12;
x.toString(2);     // ** "1100"
x.convertTo(2,8);  // ** "00001100"
x.convertTo(16,2); // ** "0c"
]]>
</description>
        </property>
      </properties>
    </element>
    <element kind="function" name="Number_toString()">
      <note title="overview">Returns a string representation of the object. Return Type: String (this method takes no arguments)</note>
      <insert>toString()</insert>
      <properties>
        <property kind="example">
          <description>
            <![CDATA[ For most objects, returns the string "[object "+className+"]". For internal objects, returns the following:ArrayEach member of the array has toString() called on it, and the results are joined together with commas. Equivalent to myArray.join().BooleanReturns "true" for true, "false" for false.DateThe format of the string value returned depends on the implementation. Often a human-readable string such as "Mon Nov 17 2003 13:56:48 GMT-0700"FunctionThe format of the string value returned depends on the implementation. Often a source-code representation of the function.NumberThe number converted to a string value. (See the specific entry for Number.toString(radix).)StringThe string's value.
</elem>]]>
</description>
        </property>
      </properties>
    </element>
    <element kind="function" name="Number_valueOf()">
      <note title="overview">Returns the internal this value of the object. Return Type: String (this method takes no arguments)</note>
      <insert>valueOf()</insert>
      <properties>
        <property kind="example">
          <description>
            <![CDATA[ For various intrinsic JS object types, this value returned is overridden and customized as follows:ArraySame as the Array.toString() method.Boolean(unchanged) The true/false value itself.DateA Number object with an integer value representing the time in milliseconds since Midnight, January 1st, 1970 UTC.Function(unchanged) A reference to the function object itself.Number(unchanged) The number value itself.Object(unchanged) A reference to the object itself.StringThe string's value.
]]>
</description>
        </property>
      </properties>
    </element>
  </group>
  <group name="RegExp">
    <note title="overview">Object representing a regular expression. Inherits from: Object</note>
    <element kind="var" name="RegExp_constructor">
      <note title="overview">A reference to the constructor class for the current object instance. Property Type: Object</note>
      <properties>
        <property kind="example">
          <description>
            <![CDATA[ Checking the constructor property for a custom object is a clean way to see its type. The following code takes objects of most any type and returns a string representation of them, suitable for use in source code. Note how the constructor property is used to check the object type of the parameter.

//For more information on this function, see http://phrogz.net/JS/Object.prototype.toSourceCode.js
Object.prototype.toSourceCode=function(hier,lv,forObj){
    var out,tabs='',idre=/^[a-z_][a-z0-9_]*$/i;
    if (!lv) lv=0;
    if (hier) tabs=Math.pow(10,lv).toString().substr(1).replace(/0/g,"\t");
    if (this.constructor==Array){
        out=(forObj?'':tabs)+'['+(hier?'\n':'');
        for (var i=0,len=this.length;i&amp;lt;len;i++){
            out+=((this[i]!=null)?this[i].toSourceCode(hier,lv+1):'null')
                +(i&amp;lt;(len-1)?',':'')+(hier?'\n':'');
        }
        return out+tabs+']';
    }else if(this.constructor==Object){
        out=(forObj?'':tabs)+'{'+(hier?'\n':'');
        for (var key in this){
            if (key!='toSourceCode'){
                out+=tabs+(hier?'\t':'')
                    +(idre.test(key)?key:("'"+key+"'"))
                    +":"+(this[key]==null?'null':this[key].toSourceCode(hier,lv+1,true))
                    +","+(hier?'\n':'');
            }
        }
        out=out.replace(/,(\n?)$/,'$1');
        return out+tabs+'}';
    }else if(this.constructor==String) return (forObj?'':tabs)+"'"+this+"'";
    else if(this.constructor==Date) return (forObj?'':tabs)+"new Date("+this.valueOf()+")";
    else return (forObj?'':tabs)+this.toString();
}

The constructor property is especially useful for distinguishing arrays from generic objects, since (per the spec) typeof(myArray) returns the string "object". The following example detects if the returned value is an array or not; if it's not, it is turned into a single-element array.

(In HTML, asking for a form element by name returns the element itself if only one named element exists, or returns an array of elements if more than one name exists. It is often convenient to treat both cases with the same code, which expects an array.)

var myForm=document.getElementById('myFormID');
var products = myForm.elements['product'];
if (products.constructor!=Array) products=[products];

The value of the constructor property is not limited to the built-in object types. The following example shows two custom classes, Mammal and Cat, where a method of the class detects the type of the instance.

function Mammal(name){
    this.name=name;
}
Mammal.prototype.toString=function(){
    if (this.constructor==Cat) return "[Cat '"+this.name+"']";
    else return "[Mammal '"+this.name+"']";
}

function Cat(name){
    this.name=name;
}
Cat.prototype=new Mammal;      //inherit from Mammal
Cat.prototype.constructor=Cat; //but keep the correct constructor

var bob = new Mammal('Bob');
var kitty = new Cat('Felix');

bob.toString();   //returns the string "[Mammal 'Bob']"
kitty.toString(); //returns the string "[Cat 'Felix']"
]]>
</description>
        </property>
      </properties>
      <insert>constructor</insert>
    </element>
    <element kind="var" name="RegExp_global">
      <note title="overview">The global flag for the regular expression.
      <br />This property is read-only. Property Type: Boolean</note>
      <properties>
        <property kind="example">
          <description>
            <![CDATA[ Corresponds to the "g" flag when creating a regular expression, and indicates whether or not the regular expression is global or not when matched against a string. See the exec() method for implications of this property.

var val;
var oneCat = /cat/; //matches a single occurrence of "cat", case-sensitive
val = oneCat.ignoreCase; // ** false
val = oneCat.global;     // ** false
val = oneCat.multiline;  // ** false

var anyCat = /cat/i; //matches a single occurence of "cat", case-insensitive
val = anyCat.ignoreCase; // ** true
val = anyCat.global;     // ** false
val = anyCat.multiline;  // ** false

var all_cats = /cat/g; //matches every occurence of "cat", case-sensitive
val = all_cats.ignoreCase; // ** false
val = all_cats.global;     // ** true
val = all_cats.multiline;  // ** false

var allCats = /cat/gi; //matches every occurence of "cat", case-insensitive
val = allCats.ignoreCase; // ** true
val = allCats.global;     // ** true
val = allCats.multiline;  // ** false

var everyLine = /^.+/gm; //matches from the start of a new line to end of that line
val = everyLine.ignoreCase; // ** false
val = everyLine.global;     // ** true
val = everyLine.multiline;  // ** true
]]>
</description>
        </property>
      </properties>
      <insert>global</insert>
    </element>
    <element kind="var" name="RegExp_ignoreCase">
      <note title="overview">The case-insensitive flag for the regular expression.
      <br />This property is read-only. Property Type: Boolean</note>
      <properties>
        <property kind="example">
          <description>
            <![CDATA[ Corresponds to the "i" flag when creating a regular expression, and indicates whether or not the regular expression is case-sensitive or not when matched against a string.

var val;
var oneCat = /cat/; //matches a single occurrence of "cat", case-sensitive
val = oneCat.ignoreCase; // ** false
val = oneCat.global;     // ** false
val = oneCat.multiline;  // ** false

var anyCat = /cat/i; //matches a single occurence of "cat", case-insensitive
val = anyCat.ignoreCase; // ** true
val = anyCat.global;     // ** false
val = anyCat.multiline;  // ** false

var all_cats = /cat/g; //matches every occurence of "cat", case-sensitive
val = all_cats.ignoreCase; // ** false
val = all_cats.global;     // ** true
val = all_cats.multiline;  // ** false

var allCats = /cat/gi; //matches every occurence of "cat", case-insensitive
val = allCats.ignoreCase; // ** true
val = allCats.global;     // ** true
val = allCats.multiline;  // ** false

var everyLine = /^.+/gm; //matches from the start of a new line to end of that line
val = everyLine.ignoreCase; // ** false
val = everyLine.global;     // ** true
val = everyLine.multiline;  // ** true
]]>
</description>
        </property>
      </properties>
      <insert>ignoreCase</insert>
    </element>
    <element kind="var" name="RegExp_lastIndex">
      <note title="overview">The string position at which to start the next match. Property Type: Number</note>
      <properties>
        <property kind="example">
          <description>
            <![CDATA[ 
]]>
</description>
        </property>
      </properties>
      <insert>lastIndex</insert>
    </element>
    <element kind="var" name="RegExp_multiline">
      <note title="overview">The multiline flag for the regular expression.
      <br />This property is read-only. Property Type: Boolean</note>
      <properties>
        <property kind="example">
          <description>
            <![CDATA[ Corresponds to the "m" flag when creating a regular expression, and indicates whether or not ^ and $ in the regular expression refer to the beginning and end of the string (multiline is false) or if they refer to the beginning and end of lines (multiline is true). 

var val;
var theFirstLine = /^.+/g; //matches from the start of the string to the first newline
val = theFirstLine.ignoreCase; // ** false
val = theFirstLine.global;     // ** true
val = theFirstLine.multiline;  // ** false

var everyLine = /^.+/gm; //matches from the start of a new line to end of that line
val = everyLine.ignoreCase; // ** false
val = everyLine.global;     // ** true
val = everyLine.multiline;  // ** true
]]>
</description>
        </property>
      </properties>
      <insert>multiline</insert>
    </element>
    <element kind="var" name="RegExp_prototype">
      <note title="overview">The prototype for a class. Property Type: Object</note>
      <properties>
        <property kind="example">
          <description>
            <![CDATA[ This property is read-only for intrinsic JS classes (e.g. the Date object) but may be re-assigned for user-defined classes.

While the prototype property is 'read-only' for intrinsic classes, it may be used to extend their functionality. For example the following code uses the prototype property of the Number object to extend all numbers to support a custom 'truncate' method:

Number.prototype.trunctate=function(){
        return this>0?Math.floor(this):Math.ceil(this);
}
var x=12.37;
var y=-12.37;

x = x.truncate(); // ** 12
y = y.truncate(); // ** -12

The following code sample shows how to use the prototype property to cause one class to inherit from another:

function Mammal(name){ 
        this.name=name;
        this.offspring=[];
} 
Mammal.prototype.haveABaby=function(){ 
        var newBaby=new this.constructor("Baby "+this.name); //Uses Cat for cats, Mammal for Mammals
        this.offspring.push(newBaby);
        return newBaby;
} 
Mammal.prototype.toString=function(){ 
        return '[Mammal "'+this.name+'"]';
} 


Cat.prototype = new Mammal;          // Here's where the inheritance occurs 
Cat.prototype.constructor=Cat;       // Otherwise instances of Cat would have a constructor of Mammal 
function Cat(name){ 
        this.name=name;
} 
Cat.prototype.toString=function(){ 
        return '[Cat "'+this.name+'"]';
} 

var msg;

var someAnimal = new Mammal('Mr. Biggles');
msg = 'someAnimal is '+someAnimal;         // ** 'someAnimal is [Mammal "Mr. Biggles"]'

var myPet = new Cat('Felix');
msg = 'myPet is '+myPet;                   // ** 'myPet is [Cat "Felix"]' 

myPet.haveABaby();                         // calls a method inherited from Mammal 
msg = myPet.offspring.length;              // ** 1
msg = "First baby is "+myPet.offspring[0]; // ** 'First baby is [Cat "Baby Felix"]'
]]>
</description>
        </property>
      </properties>
      <insert>prototype</insert>
    </element>
    <element kind="var" name="RegExp_source">
      <note title="overview">The regular expression expressed as a string.
      <br />This property is read-only. Property Type: String</note>
      <properties>
        <property kind="example">
          <description>
            <![CDATA[ 
]]>
</description>
        </property>
      </properties>
      <insert>source</insert>
    </element>
    <element kind="function" name="RegExp_exec()">
      <note title="overview">Run the regular expression against a string and return a single match. Return Type: Array</note>
      <insert>exec(%_)</insert>
      <properties>
        <property kind="parameter" name="sourceString">
          <description>String The string to run the regular expression against.</description>
        </property>
        <property kind="example">
          <description>
            <![CDATA[ If the regular expression cannot be matched in the string, null is returned. Upon a successful match, the return value is an array, with two custom properties:
var sentence = "The quick brown fox jumped over the lazy dog.";
var vowelFollowedByConsonants = /[aeiou]([^aeiou. ]+)/gi;
var firstMatch = vowelFollowedByConsonants.exec(sentence);

// ** firstMatch[0] is "ick" ... the first match found
// ** firstMatch[1] is "ck" ... the first captured expression
// ** firstMatch.index is 6 ... the location of the start of the match
// ** firstMatch.input is "The quick brown fox jumped over the lazy dog."
In the above, note that setting the global flag did not cause all the various instances to be returned. Unlike String.match(), this method only returns information about a single match. However, if the global flag is set, the lastIndex property of the regular expression is used to determine where to start the search, and is updated with each call to exec(). The following example finds all matches:

var sentence = "The quick brown fox jumped over the lazy dog.";
var vowelFollowedByConsonants = /[aeiou]([^aeiou. ]+)/gi;
var allMatches = "";

var aMatch = vowelFollowedByConsonants.exec(sentence);
while (aMatch!=null){
    allMatches+="'"+aMatch[0]+"' was found at "+aMatch.index+"\n";
    aMatch = vowelFollowedByConsonants.exec(sentence);
}
/****************************************************
allMatches is the following multi-line string:
'ick' was found at 6
'own' was found at 12
'ox' was found at 17
'ump' was found at 21
'ed' was found at 24
'ov' was found at 27
'er' was found at 29
'azy' was found at 37
'og' was found at 42
****************************************************/

Sometimes parentheses are needed to logically group portions of the regular expression, but are not wanted in the captured output. To achieve this effect, use a non-capturing expression, (?:...). The following example uses a non-capturing expression to allow a price without cents (e.g. "$14") to be matched, while keeping only the dollars and cents as captured subexpressions:
var sentence = "You bought 4 items. The total price is $ 14.37.";
var priceMatch = /the total price is \$\s*(\d+)(?:\.(\d{2}))?/i;
var price = priceMatch.exec(sentence);

// ** price[0] is "The total price is $ 14.37"
// ** price[1] is "14"
// ** price[2] is "37"
// ** price.index is 20
// ** price.input is "You bought 4 items. The total price is $ 14.37."
]]>
</description>
        </property>
      </properties>
    </element>
    <element kind="function" name="RegExp_hasOwnProperty()">
      <note title="overview">Determines if the object/instance itself has the named property or method. Return Type: Boolean</note>
      <insert>hasOwnProperty(%_)</insert>
      <properties>
        <property kind="parameter" name="propertyOrMethodName">
          <description>String The name of the property or method to look for in the object.</description>
        </property>
        <property kind="example">
          <description>
            <![CDATA[ This method returns true of the specific object instance or prototype has a property or method with the name specified. The inheritance chain is not searched. The following example illustrates this:
function Person(){ ... }
Person.prototype.breathe=function(){ ... }
var fredAstaire = new Person();
fredAstaire.dance = function(){ ... }

if (Person.prototype.hasOwnProperty('breathe')){
        // this code will execute...the above call will return true
}
if (fredAstaire.hasOwnProperty('breathe')){
        // this code will NOT execute...
        // fredAstaire knows how to 'breathe', but this is an inherited method
}
if (fredAstaire.hasOwnProperty('dance')){
        // this code will execute...the above call will return true
}
if (Person.prototype.hasOwnProperty('dance')){
        // this code will NOT execute...
        // not every Person knows how to dance
}

]]>
</description>
        </property>
      </properties>
    </element>
    <element kind="function" name="RegExp_isPrototypeOf()">
      <note title="overview">Determines if the calling object prototype is in the inheritance chain for the supplied argument. Return Type: Boolean</note>
      <insert>isPrototypeOf(%_)</insert>
      <properties>
        <property kind="parameter" name="instanceToTest">
          <description>Object The object instance to check.</description>
        </property>
        <property kind="example">
          <description>
            <![CDATA[ The following code sample shows how to use this method to test if an object instance inherits from the calling prototype:
function Mammal(){ ... }
function Human(){ ... }
Human.prototype = new Mammal; //Human inherits from Mammal
var billGates = new Human();
if (Human.isPrototypeOf(billGates)){
        //this code will NOT run...
        //you must call this method on a prototype object
}
if (Human.prototype.isPrototypeOf(billGates)){
        //this code will run...the above will return true
}
if (Mammal.prototype.isPrototypeOf(billGates)){
        //this code will run...the above will return true
}
]]>
</description>
        </property>
      </properties>
    </element>
    <element kind="function" name="RegExp_propertyIsEnumerable()">
      <note title="overview">Determines if the object/instance itself has a property or method of the supplied name which will appear in a for (prop in obj) enumeration. Return Type: Boolean</note>
      <insert>propertyIsEnumerable(%_)</insert>
      <properties>
        <property kind="parameter" name="propertyOrMethodName">
          <description>String The name of the property or method to look for.</description>
        </property>
        <property kind="example">
          <description>
            <![CDATA[ This method does not search the inheritance chain of any instance supplied. Returns false if no property/method of the supplied name exists, or if one exists but will not appear during enumeration.

In general, built-in properties and methods are not enumerable, while user-defined properties and methods are.
]]>
</description>
        </property>
      </properties>
    </element>
    <element kind="function" name="RegExp_test()">
      <note title="overview">Run the regular expression against a string; return true if a match exists, false otherwise. Return Type: Boolean</note>
      <insert>test(%_)</insert>
      <properties>
        <property kind="parameter" name="sourceString">
          <description>String The string to run the regular expression against.</description>
        </property>
        <property kind="example">
          <description>
            <![CDATA[ This method is equivalent to myRegExp.exec(sourceString)!=null (but slightly faster in the success case, since no array needs to be created). This method is appropriate when a simple test for the presence of a match is all that is needed.

function UserSaidOK(userInput){
    var validResponses = /\b(ok|yes|1|true|go|yup)\b/i;
    return validResponses.test(userInput);
}

if (UserSaidOK("I do not authorize this action!")){
    // this code will not execute...
    // validResponses.test(...) in the above function returns false for this string
}

Note that, like RegExp.exec(), if the global flag for this regular expression is set, repeated calls to this function will update the lastIndex property of the expression, which will eventually cause repeated calls to test() to return false, after the string has been exhausted.
var msg = "Hello World";
var hasAVowel  = /[aeiou]/i;
var hasAVowel2 = /[aeiou]/ig;

hasAVowel.test(msg);  //true -- matched the 'e'
hasAVowel2.test(msg); //true -- matched the 'e'

hasAVowel.test(msg);  //true -- matched the 'e'
hasAVowel2.test(msg); //true -- matched the first 'o'

hasAVowel.test(msg);  //true -- matched the 'e'
hasAVowel2.test(msg); //true -- matched the second 'o'

hasAVowel.test(msg);  //true -- matched the 'e'
hasAVowel2.test(msg); //false -- no further vowels were found

hasAVowel.test(msg);  //true -- matched the 'e'
hasAVowel2.test(msg); //true -- started over and matched the 'e'
]]>
</description>
        </property>
      </properties>
    </element>
    <element kind="function" name="RegExp_toLocaleString()">
      <note title="overview">For most objects, the same as toString() unless explicitly overridden. Return Type: String (this method takes no arguments)</note>
      <insert>toLocaleString()</insert>
      <properties>
        <property kind="example">
          <description>
            <![CDATA[ 
]]>
</description>
        </property>
      </properties>
    </element>
    <element kind="function" name="RegExp_toString()">
      <note title="overview">Returns a string representation of the object. Return Type: String (this method takes no arguments)</note>
      <insert>toString()</insert>
      <properties>
        <property kind="example">
          <description>
            <![CDATA[ For most objects, returns the string "[object "+className+"]". For internal objects, returns the following:ArrayEach member of the array has toString() called on it, and the results are joined together with commas. Equivalent to myArray.join().BooleanReturns "true" for true, "false" for false.DateThe format of the string value returned depends on the implementation. Often a human-readable string such as "Mon Nov 17 2003 13:56:48 GMT-0700"FunctionThe format of the string value returned depends on the implementation. Often a source-code representation of the function.NumberThe number converted to a string value. (See the specific entry for Number.toString(radix).)StringThe string's value.
</elem>]]>
</description>
        </property>
      </properties>
    </element>
    <element kind="function" name="RegExp_valueOf()">
      <note title="overview">Returns the internal this value of the object. Return Type: String (this method takes no arguments)</note>
      <insert>valueOf()</insert>
      <properties>
        <property kind="example">
          <description>
            <![CDATA[ For various intrinsic JS object types, this value returned is overridden and customized as follows:ArraySame as the Array.toString() method.Boolean(unchanged) The true/false value itself.DateA Number object with an integer value representing the time in milliseconds since Midnight, January 1st, 1970 UTC.Function(unchanged) A reference to the function object itself.Number(unchanged) The number value itself.Object(unchanged) A reference to the object itself.StringThe string's value.
]]>
</description>
        </property>
      </properties>
    </element>
  </group>
  <group name="String">
    <note title="overview">Basic object. Inherits from: Object</note>
    <element kind="var" name="String_constructor">
      <note title="overview">A reference to the constructor class for the current object instance. Property Type: Object</note>
      <properties>
        <property kind="example">
          <description>
            <![CDATA[ Checking the constructor property for a custom object is a clean way to see its type. The following code takes objects of most any type and returns a string representation of them, suitable for use in source code. Note how the constructor property is used to check the object type of the parameter.

//For more information on this function, see http://phrogz.net/JS/Object.prototype.toSourceCode.js
Object.prototype.toSourceCode=function(hier,lv,forObj){
    var out,tabs='',idre=/^[a-z_][a-z0-9_]*$/i;
    if (!lv) lv=0;
    if (hier) tabs=Math.pow(10,lv).toString().substr(1).replace(/0/g,"\t");
    if (this.constructor==Array){
        out=(forObj?'':tabs)+'['+(hier?'\n':'');
        for (var i=0,len=this.length;i&amp;lt;len;i++){
            out+=((this[i]!=null)?this[i].toSourceCode(hier,lv+1):'null')
                +(i&amp;lt;(len-1)?',':'')+(hier?'\n':'');
        }
        return out+tabs+']';
    }else if(this.constructor==Object){
        out=(forObj?'':tabs)+'{'+(hier?'\n':'');
        for (var key in this){
            if (key!='toSourceCode'){
                out+=tabs+(hier?'\t':'')
                    +(idre.test(key)?key:("'"+key+"'"))
                    +":"+(this[key]==null?'null':this[key].toSourceCode(hier,lv+1,true))
                    +","+(hier?'\n':'');
            }
        }
        out=out.replace(/,(\n?)$/,'$1');
        return out+tabs+'}';
    }else if(this.constructor==String) return (forObj?'':tabs)+"'"+this+"'";
    else if(this.constructor==Date) return (forObj?'':tabs)+"new Date("+this.valueOf()+")";
    else return (forObj?'':tabs)+this.toString();
}

The constructor property is especially useful for distinguishing arrays from generic objects, since (per the spec) typeof(myArray) returns the string "object". The following example detects if the returned value is an array or not; if it's not, it is turned into a single-element array.

(In HTML, asking for a form element by name returns the element itself if only one named element exists, or returns an array of elements if more than one name exists. It is often convenient to treat both cases with the same code, which expects an array.)

var myForm=document.getElementById('myFormID');
var products = myForm.elements['product'];
if (products.constructor!=Array) products=[products];

The value of the constructor property is not limited to the built-in object types. The following example shows two custom classes, Mammal and Cat, where a method of the class detects the type of the instance.

function Mammal(name){
    this.name=name;
}
Mammal.prototype.toString=function(){
    if (this.constructor==Cat) return "[Cat '"+this.name+"']";
    else return "[Mammal '"+this.name+"']";
}

function Cat(name){
    this.name=name;
}
Cat.prototype=new Mammal;      //inherit from Mammal
Cat.prototype.constructor=Cat; //but keep the correct constructor

var bob = new Mammal('Bob');
var kitty = new Cat('Felix');

bob.toString();   //returns the string "[Mammal 'Bob']"
kitty.toString(); //returns the string "[Cat 'Felix']"
]]>
</description>
        </property>
      </properties>
      <insert>constructor</insert>
    </element>
    <element kind="var" name="String_length">
      <note title="overview">The number of characters in the string.
      <br />This property is read-only. Property Type: Number</note>
      <properties>
        <property kind="example">
          <description>
            <![CDATA[ var msg = "It's the end of the world as we know it, and I feel fine.";
var len = msg.length;
// ** len is 57
]]>
</description>
        </property>
      </properties>
      <insert>length</insert>
    </element>
    <element kind="var" name="String_prototype">
      <note title="overview">The prototype for a class. Property Type: Object</note>
      <properties>
        <property kind="example">
          <description>
            <![CDATA[ This property is read-only for intrinsic JS classes (e.g. the Date object) but may be re-assigned for user-defined classes.

While the prototype property is 'read-only' for intrinsic classes, it may be used to extend their functionality. For example the following code uses the prototype property of the Number object to extend all numbers to support a custom 'truncate' method:

Number.prototype.trunctate=function(){
        return this>0?Math.floor(this):Math.ceil(this);
}
var x=12.37;
var y=-12.37;

x = x.truncate(); // ** 12
y = y.truncate(); // ** -12

The following code sample shows how to use the prototype property to cause one class to inherit from another:

function Mammal(name){ 
        this.name=name;
        this.offspring=[];
} 
Mammal.prototype.haveABaby=function(){ 
        var newBaby=new this.constructor("Baby "+this.name); //Uses Cat for cats, Mammal for Mammals
        this.offspring.push(newBaby);
        return newBaby;
} 
Mammal.prototype.toString=function(){ 
        return '[Mammal "'+this.name+'"]';
} 


Cat.prototype = new Mammal;          // Here's where the inheritance occurs 
Cat.prototype.constructor=Cat;       // Otherwise instances of Cat would have a constructor of Mammal 
function Cat(name){ 
        this.name=name;
} 
Cat.prototype.toString=function(){ 
        return '[Cat "'+this.name+'"]';
} 

var msg;

var someAnimal = new Mammal('Mr. Biggles');
msg = 'someAnimal is '+someAnimal;         // ** 'someAnimal is [Mammal "Mr. Biggles"]'

var myPet = new Cat('Felix');
msg = 'myPet is '+myPet;                   // ** 'myPet is [Cat "Felix"]' 

myPet.haveABaby();                         // calls a method inherited from Mammal 
msg = myPet.offspring.length;              // ** 1
msg = "First baby is "+myPet.offspring[0]; // ** 'First baby is [Cat "Baby Felix"]'
]]>
</description>
        </property>
      </properties>
      <insert>prototype</insert>
    </element>
    <element kind="function" name="String_charAt()">
      <note title="overview">Return the character at a particular index in the string. Return Type: String</note>
      <insert>charAt(%_)</insert>
      <properties>
        <property kind="parameter" name="pos">
          <description>Number The index of the character to retrieve.</description>
        </property>
        <property kind="example">
          <description>
            <![CDATA[ As ECMAScript does not differentiate between String types and 'character' types, the return value is actually a single-character String object. If pos is less than zero or greater than or equal to the length of the string, the result is an empty string.var msg = 'Hello World!';
var firstChar = msg.charAt(0);
var thirdChar = msg.charAt(2);
var emptyString = msg.charAt(9999);This method is equivalent to mystring.substring(pos,pos+1).
]]>
</description>
        </property>
      </properties>
    </element>
    <element kind="function" name="String_charCodeAt()">
      <note title="overview">Return the Unicode value of the character at a particular index in the string. Return Type: Number</note>
      <insert>charCodeAt(%_)</insert>
      <properties>
        <property kind="parameter" name="pos">
          <description>Number The index of the character to retrieve the Unicode character value.</description>
        </property>
        <property kind="example">
          <description>
            <![CDATA[ If pos is less than 0, or greater than or equal to the length of the string, NaN is returned.var charCodes=[];
var msg = "Hello World";
for (var i=0,len=msg.length;i&amp;lt;len;i++) charCodes.push( msg.charCodeAt(i) );
// ** charCodes is now [72,101,108,108,111,32,87,111,114,108,100]

var newMsg = String.fromCharCode(72,101,108,108,111,32,87,111,114,108,100);
// ** newMsg is "Hello World"
]]>
</description>
        </property>
      </properties>
    </element>
    <element kind="function" name="String_concat()">
      <note title="overview">Append one or more strings to the current string, and return the result. Return Type: String</note>
      <insert>concat(%_)</insert>
      <properties>
        <property kind="parameter" name="string1">
          <description>String [optional] The first string to append.</description>
        </property>
        <property kind="parameter" name="string2">
          <description>String [optional] The second string to append.</description>
        </property>
        <property kind="parameter" name="...">
          <description>String [optional] etc.</description>
        </property>
        <property kind="example">
          <description>
            <![CDATA[ The original string is not modified. If any parameters are not strings, toString() is called on them first. This is the same as origString+string1+string2+....var myString = "Hello";
var fullMessage = myString.concat(' ','World. The secret number is ',17);
// ** fullMessage is "Hello World. The secret number is 17"
// ** myString is still "Hello"
]]>
</description>
        </property>
      </properties>
    </element>
    <element kind="function" name="String_fromCharCode()">
      <note title="overview">Create a new string from a series of Unicode character values. Return Type: String</note>
      <insert>fromCharCode(%_)</insert>
      <properties>
        <property kind="parameter" name="charCode0">
          <description>Number [optional] The first Unicode character code.</description>
        </property>
        <property kind="parameter" name="charCode1">
          <description>Number [optional] The second Unicode character code.</description>
        </property>
        <property kind="parameter" name="...">
          <description>Number [optional] etc.</description>
        </property>
        <property kind="example">
          <description>
            <![CDATA[ This is a method of the String class itself, and does not apply to string instances. As such, it must be called as String.fromCharCode(...), for example:var msg = String.fromCharCode(72,101,108,108,111,32,87,111,114,108,100);
// ** msg is "Hello World"
]]>
</description>
        </property>
      </properties>
    </element>
    <element kind="function" name="String_hasOwnProperty()">
      <note title="overview">Determines if the object/instance itself has the named property or method. Return Type: Boolean</note>
      <insert>hasOwnProperty(%_)</insert>
      <properties>
        <property kind="parameter" name="propertyOrMethodName">
          <description>String The name of the property or method to look for in the object.</description>
        </property>
        <property kind="example">
          <description>
            <![CDATA[ This method returns true of the specific object instance or prototype has a property or method with the name specified. The inheritance chain is not searched. The following example illustrates this:
function Person(){ ... }
Person.prototype.breathe=function(){ ... }
var fredAstaire = new Person();
fredAstaire.dance = function(){ ... }

if (Person.prototype.hasOwnProperty('breathe')){
        // this code will execute...the above call will return true
}
if (fredAstaire.hasOwnProperty('breathe')){
        // this code will NOT execute...
        // fredAstaire knows how to 'breathe', but this is an inherited method
}
if (fredAstaire.hasOwnProperty('dance')){
        // this code will execute...the above call will return true
}
if (Person.prototype.hasOwnProperty('dance')){
        // this code will NOT execute...
        // not every Person knows how to dance
}

]]>
</description>
        </property>
      </properties>
    </element>
    <element kind="function" name="String_indexOf()">
      <note title="overview">Find the offset of a substring within the string. Return Type: String</note>
      <insert>indexOf(%_)</insert>
      <properties>
        <property kind="parameter" name="searchString">
          <description>String The substring to search for within the source string.</description>
        </property>
        <property kind="parameter" name="position">
          <description>Number [optional] The position to start searching from. If omitted, 0 (the beginning of the string) is used.</description>
        </property>
        <property kind="example">
          <description>
            <![CDATA[ If the search string exists within the calling string, the smallest index position in the calling string which is less than position is returned. If the search string does not exist in the calling string (or if all instances where it appears begin at a point less than position) then -1 is returned. Note that the search/comparison is case-sensitive. To do a case-insensitive test, see RegExp.test()

var sentence="The quick brown fox jumped over the lazy dog.";
var loc = sentence.indexOf('the');
// ** loc is 32, because "The" at position 0 is not the same as "the" which was searched for

var oLocations = [];
loc = sentence.indexOf('o');
while (loc!=-1){
    oLocations.push(loc);
    loc = sentence.indexOf('o',loc+1);
}
// ** oLocations is [12,17,27,42]
]]>
</description>
        </property>
      </properties>
    </element>
    <element kind="function" name="String_isPrototypeOf()">
      <note title="overview">Determines if the calling object prototype is in the inheritance chain for the supplied argument. Return Type: Boolean</note>
      <insert>isPrototypeOf(%_)</insert>
      <properties>
        <property kind="parameter" name="instanceToTest">
          <description>Object The object instance to check.</description>
        </property>
        <property kind="example">
          <description>
            <![CDATA[ The following code sample shows how to use this method to test if an object instance inherits from the calling prototype:
function Mammal(){ ... }
function Human(){ ... }
Human.prototype = new Mammal; //Human inherits from Mammal
var billGates = new Human();
if (Human.isPrototypeOf(billGates)){
        //this code will NOT run...
        //you must call this method on a prototype object
}
if (Human.prototype.isPrototypeOf(billGates)){
        //this code will run...the above will return true
}
if (Mammal.prototype.isPrototypeOf(billGates)){
        //this code will run...the above will return true
}
]]>
</description>
        </property>
      </properties>
    </element>
    <element kind="function" name="String_lastIndexOf()">
      <note title="overview">The offset of a substring within the string. Return Type: String</note>
      <insert>lastIndexOf(%_)</insert>
      <properties>
        <property kind="parameter" name="searchString">
          <description>String The substring to search for within the source string.</description>
        </property>
        <property kind="parameter" name="position">
          <description>Number [optional] The position to start searching at or before. If omitted, 
          <code>length-1</code>(the end of the string) is used.</description>
        </property>
        <property kind="example">
          <description>
            <![CDATA[ Like String.indexOf(), this search is case sensitive, and returns -1 if the search string cannot be found. Unlike that method, this method begins its search from the end of the string (or position, if it is smaller) and searches backwards.var sentence="The quick brown fox jumped over the lazy dog.";
var oLocations = [];
loc = sentence.lastIndexOf('o');
while (loc!=-1){
    oLocations.push(loc);
    loc = sentence.lastIndexOf('o',loc-1);
}
// ** oLocations is [42,27,17,12]

var url = "http://phrogz.net/ObjJob/../methods.html";
var path = url.substring( 0 , url.lastIndexOf('/')+1 );
// ** path is "http://phrogz.net/ObjJob/"
]]>
</description>
        </property>
      </properties>
    </element>
    <element kind="function" name="String_localeCompare()">
      <note title="overview">Compare the string to the argument in the current locale. Return Type: Number</note>
      <insert>localeCompare(%_)</insert>
      <properties>
        <property kind="parameter" name="compareString">
          <description>String The string to compare to the calling string.</description>
        </property>
        <property kind="example">
          <description>
            <![CDATA[ This return value of this function depends on the specific implementation. From the specification:<blockquote>"The result is intended to order strings in the sort order specified by the system default locale, and will be negative, zero, or positive, depending on whether [the calling string] comes before [compareString] in the sort order, the strings are equal, or [the calling string] comes [compareString] that in the sort order, respectively."</blockquote>
]]>
</description>
        </property>
      </properties>
    </element>
    <element kind="function" name="String_match()">
      <note title="overview">Run the supplied regular expression against the string and return an array of the results. Return Type: Array</note>
      <insert>match(%_)</insert>
      <properties>
        <property kind="parameter" name="expr">
          <description>RegExp The regular expression to match against string.</description>
        </property>
        <property kind="example">
          <description>
            <![CDATA[ If expr has the global flag set (true), this returns an array of strings of all matches found by calling expr.exec(myString) repeatedly.If expr has the global flag unset (false), this returns the same array as RegExp.exec(myString).

var description = "The various items cost $4.34, $7.12, $8, $8.25, and even $12.04";
var firstPriceRE = /\$\d*(\.\d{2})?/;
var allPricesRE  = /\$\d*(\.\d{2})?/g;

var price = description.match(firstPriceRE);
// ** price is ['$4.34','.34']

var prices = description.match(allPricesRE);
// ** prices is ['$4.34','$7.12','$8','$8.25','$12.04']To use a regular expression to test against a string, use RegExp.test() instead of this method for better performance.
]]>
</description>
        </property>
      </properties>
    </element>
    <element kind="function" name="String_propertyIsEnumerable()">
      <note title="overview">Determines if the object/instance itself has a property or method of the supplied name which will appear in a for (prop in obj) enumeration. Return Type: Boolean</note>
      <insert>propertyIsEnumerable(%_)</insert>
      <properties>
        <property kind="parameter" name="propertyOrMethodName">
          <description>String The name of the property or method to look for.</description>
        </property>
        <property kind="example">
          <description>
            <![CDATA[ This method does not search the inheritance chain of any instance supplied. Returns false if no property/method of the supplied name exists, or if one exists but will not appear during enumeration.

In general, built-in properties and methods are not enumerable, while user-defined properties and methods are.
]]>
</description>
        </property>
      </properties>
    </element>
    <element kind="function" name="String_replace()">
      <note title="overview">Find and replace values in a string, and return the changed string. Return Type: String</note>
      <insert>replace(%_)</insert>
      <properties>
        <property kind="parameter" name="searchExpr">
          <description>Object Either a literal String or Regular Expression to search for.</description>
        </property>
        <property kind="parameter" name="replaceExpr">
          <description>Object Either a String value to replace each found instance with, or a function which returns a String to replace each found instance with (see below)</description>
        </property>
        <property kind="example">
          <description>
            <![CDATA[ If searchExpr is a string, a case-sensitive search is performed, and only the first match found is replaced. To make a case-insensitive replacement or global replacement, use a regular expression for the search expression.var sentence = "The quick brown fox and the duck jump over the lazy dog.";
var oneReplaced = sentence.replace( 'the' , '**the**' );
var allReplaced = sentence.replace( /the/gi , '**the**' );
// ** oneReplaced is "The quick brown fox and **the** duck jump over the lazy dog."
// ** allReplaced is "**the** quick brown fox and **the** duck jump over **the** lazy dog."

When searchExpr is a regular expression and replaceExpr is a string, the following substrings have special meaning:



        $&amp;
        The entire matched substring.

        $`
        The portion of the original string that precedes the matched substring.
        
        $'
        The portion of the original string that follows the matched substring

        $<i>n</i>
        The <i>n</i><sup>th</sup> captured subexpression, where <i>n</i> is a single digit and $<i>n</i> is not followed by another digit.

        $<i>nn</i>
        The <i>nn</i><sup>th</sup> captured subexpression, where <i>nn</i> is a two-digit number.
        
        $$
        Replace with a literal "$"


var sentence = "The quick brown fox jumps over the lazy dog.";
var blankouts = sentence.replace( /\b([a-z])[a-z]+/gi , '$1****' );
// ** alternatedBlankouts is "T**** q**** b**** f**** j**** o**** t**** l**** d****."

If replaceExpr is a function, it will be passed the following arguments, in order:The substring that was matched.If searchExpr is a regular expression, one argument for each parentheses-captured substring in the expression will be passed.The next-to-last argument will be the index in the source string where the match occurred.The last argument passed is the entire source string.
var sourceString = "It's the end of the world as we know it, and I feel fine.";
function SwapCharacterPairs(str,sub1,sub2,index,srcString){
    return sub2+sub1;
}
var newString = sourceString.replace( /(.)(.)/g , SwapCharacterPairs );
// ** newString is "tIs't ehe dno  fht eowlr dsaw  enkwoi ,ta dnI f ee lifen.";
var prices = "Items cost stuff. Candy: $.50; Glasses: $3.75; 500 pages: $4.99";
var priceRE = /\$(\d*(\.\d{2})?)/g;
function IncreasePrice(str,price){
    // all the extra parameters that we don't need are ignored
    return '$'+Math.round(price*1.66*100)/100;
}
var newPrices = prices.replace(priceRE,IncreasePrice);
// ** newPrices is "Items cost stuff. Candy: $0.83; Glasses: $6.23; 500 pages: $8.28"
]]>
</description>
        </property>
      </properties>
    </element>
    <element kind="function" name="String_search()">
      <note title="overview">Find the offset of a regular expression within the string. Return Type: Number</note>
      <insert>search(%_)</insert>
      <properties>
        <property kind="parameter" name="searchExpr">
          <description>RegExp The regular expression to search for.</description>
        </property>
        <property kind="example">
          <description>
            <![CDATA[ Like String.indexOf(), this method returns the first index offset in the string where searchExpr occurs, or -1 if the regular expression cannot be found.
The global property of the regular expression, if set, is ignored. Only the first location is found, and unlike indexOf() there is no second parameter to start the search after a particular point. (Although this can be achieved equivalently via myString.slice(10).search(searchExpr).)var sentence = "I'm in a hurry to get things done. I rush and rush until life's no fun.";
sentence += " All I really gotta do is live and die, but I'm in a hurry and don't know why.";
var wordsWithVowelBeforeN = /[a-z]*[aeiou]n[a-z']*/gi;
var allWords = sentence.match(wordsWithVowelBeforeN);
// ** allWords is ["in","things","done","and","until","fun","and","in","and","don't"]

var locationOfFirstMatch = sentence.search(wordsWithVowelBeforeN);
// ** locationOfFirstMatch is 4
]]>
</description>
        </property>
      </properties>
    </element>
    <element kind="function" name="String_slice()">
      <note title="overview">Return a specified subsection of the string. Return Type: String</note>
      <insert>slice(%_)</insert>
      <properties>
        <property kind="parameter" name="start">
          <description>Number The index to start from.</description>
        </property>
        <property kind="parameter" name="end">
          <description>Number [optional] The index to stop before.</description>
        </property>
        <property kind="example">
          <description>
            <![CDATA[ This method creates a new string and copies the characters from the start index up to (but not including) the end index.If end is omitted, the copying continues from the start to the end of the string.If either start or end are negative, they are treated as offsets from the end of the string.If end occurs before (or is the same as) start, an empty string is returned.var msg = "Hello World";
var s1 = msg.slice(0,3);  // ** s1 is "Hel"
var s2 = msg.slice(6,10); // ** s2 is "Worl"
var s3 = msg.slice(-3);   // ** s3 is "rld"
var s4 = msg.slice(0,-2); // ** s4 is "Hello Wor"
var s5 = msg.slice(3);    // ** s5 is "lo World"
]]>
</description>
        </property>
      </properties>
    </element>
    <element kind="function" name="String_split()">
      <note title="overview">Separate the string into pieces and return an array of the resulting substrings. Return Type: Array</note>
      <insert>split(%_)</insert>
      <properties>
        <property kind="parameter" name="separator">
          <description>Object [optional] Either a String or Regular Expression which defines the string to split on.</description>
        </property>
        <property kind="parameter" name="limit">
          <description>Number [optional] The maximum number of substrings to return in the array.</description>
        </property>
        <property kind="example">
          <description>
            <![CDATA[ The pieces of the string matched by separator are not included in the results. The following example takes a comma-delimited string and turns it into an array of strings:var names = "Gavin,Bjornar,Thayer,Lisa,Linden,Chandra";
names = names.split( ',' );
// ** names is now an array of strings:
// ** ['Gavin','Bjornar','Thayer','Lisa','Linden','Chandra']

If limit is supplied, the resulting array will be truncated to have no more elements than specified by limit:var names = "Gavin,Bjornar,Thayer,Lisa,Linden,Chandra";
names = names.split( ',' , 3 );
// ** names is now ['Gavin','Bjornar','Thayer']

The string specified by separator does not have to be a single character:

var names = "Gavin :: Bjornar :: Thayer :: Lisa :: Linden";
names = names.split(' :: ');
// ** names is now ['Gavin','Bjornar','Thayer','Lisa','Linden','Chandra']

Specifying a regular expression for separator allows you to split the string based on a variety of criteria:

var sentence = "It's the end of the world as we know it, and I feel fine.";
var words = sentence.split(/[\s.,]+/);
// ** words is ["It's","the","end","of","the","world","as","we","know","it","and","I","feel","fine",""]

Note in the above that there is an empty string at the end of the array. This is because the final period was included as a separator by the regular expression.

If the regular expression used to split the string has captured subexpressions in it, the captured text is included in the split resultsvar html = "Hello &amp;lt;b&amp;gt;World&amp;lt;/b&amp;gt;, how &amp;lt;em&amp;gt;are&amp;lt;/em&amp;gt; you?";
var code = html.split( / *&amp;lt;(\/?[^&amp;gt;]+)&amp;gt;,? */ );
// ** code is ['Hello','b','World','/b','how','em','are','/em','you?']

If separator is an empty string, then an array is returned of every character in the original string:

var msg = "Hello World";
var letters = msg.split('');
// ** letters is ['H','e','l','l','o',' ','W','o','r','l','d']

Finally, if separator is omitted, a single-element array with the source string in it is returned:

var msg = "Hello World";
var result = msg.split();
// ** result is ['Hello World']
]]>
</description>
        </property>
      </properties>
    </element>
    <element kind="function" name="String_substring()">
      <note title="overview">Return a specified subsection of the string. Return Type: String</note>
      <insert>substring(%_)</insert>
      <properties>
        <property kind="parameter" name="start">
          <description>Number The index to start from.</description>
        </property>
        <property kind="parameter" name="end">
          <description>Number [optional] The index to stop before. If omitted, the 
          <code>length</code>of the original string is used.</description>
        </property>
        <property kind="example">
          <description>
            <![CDATA[ Like String.slice(), this method returns a subsection of the string starting and start and proceeding up to (but not including) end. Unlike slice(), if either argument is negative (or NaN), it is treated as 0, not as an offset from the end of the string. Further, if end occurs before start, the values are swapped and a valid subsection of the string is returned.var msg = "Hello World";
var s1 = msg.substring(0,3);  // ** s1 is "Hel"
var s2 = msg.substring(6,10); // ** s2 is "Worl"
var s3 = msg.substring(10,6); // ** s3 is "Worl"
var s4 = msg.substring(3,-2); // ** s4 is "Hel"
var s5 = msg.substring(3);    // ** s5 is "lo World"
]]>
</description>
        </property>
      </properties>
    </element>
    <element kind="function" name="String_toLocaleLowerCase()">
      <note title="overview">Return a locale-specific lowercase version of the string. Return Type: String (this method takes no arguments)</note>
      <insert>toLocaleLowerCase()</insert>
      <properties>
        <property kind="example">
          <description>
            <![CDATA[ This function works exactly the same as toLowerCase() except that its result is intended to yield the correct result for the host environment's current locale, rather than a locale-independent result. There will only be a difference in the few cases (such as Turkish) where the rules for that language conflict with the regular Unicode case mappings.
]]>
</description>
        </property>
      </properties>
    </element>
    <element kind="function" name="String_toLocaleString()">
      <note title="overview">For most objects, the same as toString() unless explicitly overridden. Return Type: String (this method takes no arguments)</note>
      <insert>toLocaleString()</insert>
      <properties>
        <property kind="example">
          <description>
            <![CDATA[ 
]]>
</description>
        </property>
      </properties>
    </element>
    <element kind="function" name="String_toLocaleUpperCase()">
      <note title="overview">Return a locale-specific uppercase version of the string. Return Type: String (this method takes no arguments)</note>
      <insert>toLocaleUpperCase()</insert>
      <properties>
        <property kind="example">
          <description>
            <![CDATA[ This function works exactly the same as toUpperCase() except that its result is intended to yield the correct result for the host environment's current locale, rather than a locale-independent result. There will only be a difference in the few cases (such as Turkish) where the rules for that language conflict with the regular Unicode case mappings.
]]>
</description>
        </property>
      </properties>
    </element>
    <element kind="function" name="String_toLowerCase()">
      <note title="overview">Return a lowercase version of the string. Return Type: String (this method takes no arguments)</note>
      <insert>toLowerCase()</insert>
      <properties>
        <property kind="example">
          <description>
            <![CDATA[ Note that the original string is not modified.var msg = "Hello Visitor #589, how are You?";
var msg2 = msg.toLowerCase();
// ** msg2 is "hello visitor #589, how are you?"
// ** msg is still "Hello Visitor #589, how are You?"
]]>
</description>
        </property>
      </properties>
    </element>
    <element kind="function" name="String_toString()">
      <note title="overview">Returns a string representation of the object. Return Type: String (this method takes no arguments)</note>
      <insert>toString()</insert>
      <properties>
        <property kind="example">
          <description>
            <![CDATA[ For most objects, returns the string "[object "+className+"]". For internal objects, returns the following:ArrayEach member of the array has toString() called on it, and the results are joined together with commas. Equivalent to myArray.join().BooleanReturns "true" for true, "false" for false.DateThe format of the string value returned depends on the implementation. Often a human-readable string such as "Mon Nov 17 2003 13:56:48 GMT-0700"FunctionThe format of the string value returned depends on the implementation. Often a source-code representation of the function.NumberThe number converted to a string value. (See the specific entry for Number.toString(radix).)StringThe string's value.
</elem>]]>
</description>
        </property>
      </properties>
    </element>
    <element kind="function" name="String_toUpperCase()">
      <note title="overview">Return an uppercase version of the string. Return Type: String (this method takes no arguments)</note>
      <insert>toUpperCase()</insert>
      <properties>
        <property kind="example">
          <description>
            <![CDATA[ Note that the original string is not modified.var msg = "Hello Visitor #589, how are You?";
var msg2 = msg.toUpperCase();
// ** msg2 is "HELLO VISITOR #589, HOW ARE YOU?"
// ** msg is still "Hello Visitor #589, how are You?"
]]>
</description>
        </property>
      </properties>
    </element>
    <element kind="function" name="String_valueOf()">
      <note title="overview">Returns the internal this value of the object. Return Type: String (this method takes no arguments)</note>
      <insert>valueOf()</insert>
      <properties>
        <property kind="example">
          <description>
            <![CDATA[ For various intrinsic JS object types, this value returned is overridden and customized as follows:ArraySame as the Array.toString() method.Boolean(unchanged) The true/false value itself.DateA Number object with an integer value representing the time in milliseconds since Midnight, January 1st, 1970 UTC.Function(unchanged) A reference to the function object itself.Number(unchanged) The number value itself.Object(unchanged) A reference to the object itself.StringThe string's value.
]]>
</description>
        </property>
      </properties>
    </element>
  </group>
  <group name="undefined">
    <note title="overview">The static value "undefined"</note>
  </group>
</ref>
