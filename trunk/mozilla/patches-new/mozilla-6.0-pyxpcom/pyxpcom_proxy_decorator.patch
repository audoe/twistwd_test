# HG changeset patch
# Parent 7ce5722526d0db0ff225e9c44a8a0f0ff9cdd2e9
importing patch pyxpcom_proxy_decorator.patch

diff --git a/xpcom/components.py b/xpcom/components.py
--- a/xpcom/components.py
+++ b/xpcom/components.py
@@ -215,16 +215,66 @@ classes = _Classes()
 
 del _Classes
 
 del _ComponentCollection
 
 # The ID function
 ID = _xpcom.IID
 
+
+# Internal proxy'ing class.
+class _ProxiedMethod(object):
+    """Used to proxy a method call to the main thread."""
+    _com_interfaces_ = [interfaces.nsIObserver]
+
+    def __init__(self, fn, *args, **kwargs):
+        self.fn = fn
+        self.args = args
+        self.kwargs = kwargs
+        self.result = None
+
+    def observe(self, *args):
+        self.result = self.fn(*self.args, **self.kwargs)
+        # Null out values.
+        self.fn = None
+        self.args = None
+        self.kwargs = None
+
+# This ProxyToMainThread method will proxy the given function through to
+# the main thread (synchronously). It does this by creating a
+# ProxiedMethod instance, which it uses to imitate an XPCOM call
+# (nsIObserver.observe), this observe method is then called on the main
+# thread, which in turn will call the original method that we wanted to
+# be proxied. Once the observe call is done, the result of proxied
+# method is returned.
+#
+# Note: Each call made to the 'fn' will create a new proxy object, which
+#       ensures that every call made to 'fn' is proxied no matter what
+#       thread is calling the function.
+#
+def ProxyToMainThread(fn):
+    """Synchronously call fn on the main thread and return the result."""
+    import threading
+    def wrapperFn(*args, **kwargs):
+        if threading.currentThread().name != "MainThread":
+            method = _ProxiedMethod(fn, *args, **kwargs)
+            proxiedMethod = _xpcom.getProxyForObject(1,
+                                                     interfaces.nsIObserver,
+                                                     method,
+                                                     _xpcom.PROXY_SYNC | _xpcom.PROXY_ALWAYS)
+            proxiedMethod.observe(None, "", "")
+            result = method.result
+            method.result = None
+            return result
+        else:
+            return fn(*args, **kwargs)
+    return wrapperFn
+
+
 def _on_shutdown():
     global manager, registrar, classes, interfaces, interfaceInfoManager, serviceManager, _constants_by_iid_map
     manager = registrar = classes = interfaces = interfaceInfoManager = serviceManager = _constants_by_iid_map = None
     # for historical reasons we call these manually.
     xpcom.client._shutdown()
     xpcom.server._shutdown()
 
 # import xpcom.shutdown late as it depends on us!
