# HG changeset patch
# Parent 2c5ea850ab458cb8e927300ddb865aefc60956dd
If you start dragging text in a editor window, once you move towards the bottom
of the editor window, the editor screen will start scrolling down (normal and
expected). If you keep dragging till you are over the horizontal scrollbar,
suddely the scrolling changes to be scrolling upwards (bad, unexpected).

This is because all of the event Y co-ordinates for onDragOver are incorrect,
they are relative to the scrollbar element and not the editor screen. We fix
this by finding the outer Mozilla window (nsWindow) and re-adjusting the event
co-ordinates to be relevant to the Mozilla window instead of the GTK widget.

diff --git a/widget/src/gtk2/nsWindow.cpp b/widget/src/gtk2/nsWindow.cpp
--- a/widget/src/gtk2/nsWindow.cpp
+++ b/widget/src/gtk2/nsWindow.cpp
@@ -169,19 +169,19 @@ static PRBool     check_for_rollup(GdkWi
                                    PRBool aIsWheel, PRBool aAlwaysRollup);
 static PRBool     is_mouse_in_window(GdkWindow* aWindow,
                                      gdouble aMouseX, gdouble aMouseY);
 static nsWindow  *get_window_for_gtk_widget(GtkWidget *widget);
 static nsWindow  *get_window_for_gdk_window(GdkWindow *window);
 static GtkWidget *get_gtk_widget_for_gdk_window(GdkWindow *window);
 static GdkCursor *get_gtk_cursor(nsCursor aCursor);
 
-static GdkWindow *get_inner_gdk_window (GdkWindow *aWindow,
-                                        gint x, gint y,
-                                        gint *retx, gint *rety);
+static nsWindow *get_innermost_window_for_gdk_window(GdkWindow *outerGtkWindow,
+                                                     gint x, gint y,
+                                                     gint *retx, gint *rety);
 
 static inline PRBool is_context_menu_key(const nsKeyEvent& inKeyEvent);
 static void   key_event_to_context_menu_event(nsMouseEvent &aEvent,
                                               GdkEventKey *aGdkEvent);
 
 static int    is_parent_ungrab_enter(GdkEventCrossing *aEvent);
 static int    is_parent_grab_leave(GdkEventCrossing *aEvent);
 
@@ -3493,19 +3493,19 @@ nsWindow::OnDragMotionEvent(GtkWidget *a
     nsCOMPtr<nsIDragService> dragService = do_GetService(kCDragServiceCID);
     nsCOMPtr<nsIDragSessionGTK> dragSessionGTK = do_QueryInterface(dragService);
 
     // first, figure out which internal widget this drag motion actually
     // happened on
     nscoord retx = 0;
     nscoord rety = 0;
 
-    GdkWindow *innerWindow = get_inner_gdk_window(aWidget->window, aX, aY,
-                                                  &retx, &rety);
-    nsRefPtr<nsWindow> innerMostWidget = get_window_for_gdk_window(innerWindow);
+    GdkWindow *thisWindow = aWidget->window;
+    nsRefPtr<nsWindow> innerMostWidget = get_innermost_window_for_gdk_window(thisWindow, aX, aY,
+                                                          &retx, &rety);
 
     if (!innerMostWidget)
         innerMostWidget = this;
 
     // update the drag context
     dragSessionGTK->TargetSetLastContext(aWidget, aDragContext, aTime);
 
     // clear any drag leave timer that might be pending so that it
@@ -3582,19 +3582,19 @@ nsWindow::OnDragDropEvent(GtkWidget *aWi
 
     // get our drag context
     nsCOMPtr<nsIDragService> dragService = do_GetService(kCDragServiceCID);
     nsCOMPtr<nsIDragSessionGTK> dragSessionGTK = do_QueryInterface(dragService);
 
     nscoord retx = 0;
     nscoord rety = 0;
 
-    GdkWindow *innerWindow = get_inner_gdk_window(aWidget->window, aX, aY,
-                                                  &retx, &rety);
-    nsRefPtr<nsWindow> innerMostWidget = get_window_for_gdk_window(innerWindow);
+    GdkWindow *thisWindow = aWidget->window;
+    nsRefPtr<nsWindow> innerMostWidget = get_innermost_window_for_gdk_window(thisWindow, aX, aY,
+                                                          &retx, &rety);
 
     if (!innerMostWidget)
         innerMostWidget = this;
 
     // set this now before any of the drag enter or leave events happen
     dragSessionGTK->TargetSetLastContext(aWidget, aDragContext, aTime);
 
     // clear any drag leave timer that might be pending so that it
@@ -6190,13 +6190,13 @@
 nsWindow::DragLeaveTimerCallback(nsITimer *aTimer, void *aClosure)
 {
     nsRefPtr<nsWindow> window = static_cast<nsWindow *>(aClosure);
     window->FireDragLeaveTimer();
 }
 
-static GdkWindow *
+inline GdkWindow *
 get_inner_gdk_window (GdkWindow *aWindow,
                       gint x, gint y,
                       gint *retx, gint *rety)
 {
     gint cx, cy, cw, ch, cd;
     GList *children = gdk_window_peek_children(aWindow);
@@ -6217,12 +6217,47 @@
     }
     *retx = x;
     *rety = y;
     return aWindow;
 }
 
+/* static */
+nsWindow *
+get_innermost_window_for_gdk_window(GdkWindow *outerGtkWindow,
+                                    gint x, gint y,
+                                    gint *retx, gint *rety)
+{
+    gint cx, cy, cw, ch, cd;
+    GdkWindow *innerGtkWindow = NULL;
+
+    /* Get the inner most gdkWindow with these co-ordinates */
+    innerGtkWindow = get_inner_gdk_window(outerGtkWindow, x, y, retx, rety);
+
+    /* Return the first nsWindow this widget belongs to */
+    while (innerGtkWindow) {
+        if (g_object_get_data(G_OBJECT(innerGtkWindow), "nsWindow")) {
+            return get_window_for_gdk_window(innerGtkWindow);
+        }
+        if (innerGtkWindow == outerGtkWindow) {
+            /* No nsWindow found, we've already searched all the gtk windows */
+            break;
+        }
+        /* Not a nsWindow yet, try the parent then, but first */
+        /* we have to update the retx & rety co-ordinates     */
+        gdk_window_get_geometry (innerGtkWindow, &cx, &cy, &cw, &ch, &cd);
+        *retx += cx;
+        *rety += cy;
+        innerGtkWindow = gdk_window_get_parent(innerGtkWindow);
+    }
+
+    /* No appropriate nsWindow found */
+    *retx = 0;
+    *rety = 0;
+    return nsnull;
+}
+
 static inline PRBool
 is_context_menu_key(const nsKeyEvent& aKeyEvent)
 {
     return ((aKeyEvent.keyCode == NS_VK_F10 && aKeyEvent.isShift &&
              !aKeyEvent.isControl && !aKeyEvent.isMeta && !aKeyEvent.isAlt) ||
             (aKeyEvent.keyCode == NS_VK_CONTEXT_MENU && !aKeyEvent.isShift &&
