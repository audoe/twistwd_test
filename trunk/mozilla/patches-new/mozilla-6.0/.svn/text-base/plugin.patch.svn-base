# HG changeset patch
# Parent f011d19ec2118dfbe3613de06a69317fb9d4f147
importing patch plugin.patch

diff --git a/layout/generic/nsObjectFrame.cpp b/layout/generic/nsObjectFrame.cpp
--- a/layout/generic/nsObjectFrame.cpp
+++ b/layout/generic/nsObjectFrame.cpp
@@ -498,6 +498,11 @@ public:
              mPluginWindow->type == NPWindowTypeDrawable));
   }
 
+  PRBool AllowsFocus()
+  {
+    return mPluginAllowsFocus;
+  }
+
 private:
 
   // return FALSE if LayerSurface dirty (newly created and don't have valid plugin content yet)
@@ -562,6 +567,9 @@ private:
   // If true, destroy the widget on destruction. Used when plugin stop
   // is being delayed to a safer point in time.
   PRPackedBool                mDestroyWidget;
+  PRPackedBool                mPluginAllowsFocus;
+  PRPackedBool                mPluginHandlesDomEvents;
+  PRPackedBool                mPluginHandlesDragEvents;
   PRUint16          mNumCachedAttrs;
   PRUint16          mNumCachedParams;
   char              **mCachedAttrParamNames;
@@ -947,8 +955,9 @@ nsObjectFrame::CreateWidget(nscoord aWid
   return (needsWidget && !canCreateWidget) ? NS_ERROR_NOT_AVAILABLE : NS_OK;
 }
 
-#define EMBED_DEF_WIDTH 240
-#define EMBED_DEF_HEIGHT 200
+// XXX ActiveState
+#define EMBED_DEF_WIDTH 20
+#define EMBED_DEF_HEIGHT 20
 
 /* virtual */ nscoord
 nsObjectFrame::GetMinWidth(nsIRenderingContext *aRenderingContext)
@@ -1246,6 +1255,9 @@ nsObjectFrame::CallSetWindow(PRBool aChe
 PRBool
 nsObjectFrame::IsFocusable(PRInt32 *aTabIndex, PRBool aWithMouse)
 {
+  if (mInstanceOwner && !mInstanceOwner->AllowsFocus()) {
+    return PR_FALSE;
+  }
   if (aTabIndex)
     *aTabIndex = -1;
   return nsObjectFrameSuper::IsFocusable(aTabIndex, aWithMouse);
@@ -3193,6 +3205,9 @@ nsPluginInstanceOwner::nsPluginInstanceO
   mCachedAttrParamNames = nsnull;
   mCachedAttrParamValues = nsnull;
   mDestroyWidget = PR_FALSE;
+  mPluginAllowsFocus = PR_TRUE;
+  mPluginHandlesDomEvents = PR_FALSE;
+  mPluginHandlesDragEvents = PR_FALSE;
 
 #ifdef MOZ_COMPOSITED_PLUGINS
   mLastPoint = nsIntPoint(0,0);
@@ -5394,8 +5409,15 @@ nsEventStatus nsPluginInstanceOwner::Pro
       !(anEvent.eventStructType == NS_MOUSE_EVENT &&
         anEvent.message == NS_MOUSE_BUTTON_DOWN &&
         static_cast<const nsMouseEvent&>(anEvent).button == nsMouseEvent::eLeftButton &&
-        !mContentFocused))
+        !mContentFocused)) {
     rv = nsEventStatus_eConsumeNoDefault;
+  } else {
+    /* KOMODO: For the Mac, we want the plugin to determine what happens to
+               this event, whether this event is consumed or not
+     */
+    rv = (response == kNPEventNotHandled) ? nsEventStatus_eIgnore :
+                                            nsEventStatus_eConsumeNoDefault;
+  }
 
   pluginWidget->EndDrawPlugin();
 #endif
@@ -5766,7 +5788,7 @@ nsPluginInstanceOwner::Destroy()
   }
 
   nsCOMPtr<nsIDOMEventTarget> target(do_QueryInterface(mContent));
-  if (target) {
+  if (target && mPluginHandlesDomEvents) {
 
     nsCOMPtr<nsIDOMEventListener> listener;
     QueryInterface(NS_GET_IID(nsIDOMEventListener), getter_AddRefs(listener));
@@ -5785,17 +5807,19 @@ nsPluginInstanceOwner::Destroy()
     target->RemoveEventListener(NS_LITERAL_STRING("keydown"), listener, PR_TRUE);
     target->RemoveEventListener(NS_LITERAL_STRING("keyup"), listener, PR_TRUE);
 
-    // Unregister drag event listener;
-    target->RemoveEventListener(NS_LITERAL_STRING("drop"), listener, PR_TRUE);
-    target->RemoveEventListener(NS_LITERAL_STRING("dragdrop"), listener, PR_TRUE);
-    target->RemoveEventListener(NS_LITERAL_STRING("drag"), listener, PR_TRUE);
-    target->RemoveEventListener(NS_LITERAL_STRING("dragenter"), listener, PR_TRUE);
-    target->RemoveEventListener(NS_LITERAL_STRING("dragover"), listener, PR_TRUE);
-    target->RemoveEventListener(NS_LITERAL_STRING("dragexit"), listener, PR_TRUE);
-    target->RemoveEventListener(NS_LITERAL_STRING("dragleave"), listener, PR_TRUE);
-    target->RemoveEventListener(NS_LITERAL_STRING("dragstart"), listener, PR_TRUE);
-    target->RemoveEventListener(NS_LITERAL_STRING("draggesture"), listener, PR_TRUE);
-    target->RemoveEventListener(NS_LITERAL_STRING("dragend"), listener, PR_TRUE);
+    if (mPluginHandlesDragEvents) {
+      // Unregister drag event listener;
+      target->RemoveEventListener(NS_LITERAL_STRING("drop"), listener, PR_TRUE);
+      target->RemoveEventListener(NS_LITERAL_STRING("dragdrop"), listener, PR_TRUE);
+      target->RemoveEventListener(NS_LITERAL_STRING("drag"), listener, PR_TRUE);
+      target->RemoveEventListener(NS_LITERAL_STRING("dragenter"), listener, PR_TRUE);
+      target->RemoveEventListener(NS_LITERAL_STRING("dragover"), listener, PR_TRUE);
+      target->RemoveEventListener(NS_LITERAL_STRING("dragexit"), listener, PR_TRUE);
+      target->RemoveEventListener(NS_LITERAL_STRING("dragleave"), listener, PR_TRUE);
+      target->RemoveEventListener(NS_LITERAL_STRING("dragstart"), listener, PR_TRUE);
+      target->RemoveEventListener(NS_LITERAL_STRING("draggesture"), listener, PR_TRUE);
+      target->RemoveEventListener(NS_LITERAL_STRING("dragend"), listener, PR_TRUE);
+    }
   }
 
   if (mWidget) {
@@ -6559,7 +6583,19 @@ nsresult nsPluginInstanceOwner::Init(nsP
   }
 
   nsCOMPtr<nsIDOMEventTarget> target(do_QueryInterface(mContent));
-  if (target) {
+
+  if (target && mContent->AttrValueIs(kNameSpaceID_None,
+                                      nsGkAtoms::pluginAllowsFocusEvents,
+                                      nsGkAtoms::_false,
+                                      eCaseMatters)) {
+    mPluginAllowsFocus = PR_FALSE;
+  }
+
+  if (target && !mContent->AttrValueIs(kNameSpaceID_None,
+                                       nsGkAtoms::pluginHandlesDomEvents,
+                                       nsGkAtoms::_false,
+                                       eCaseMatters)) {
+    mPluginHandlesDomEvents = PR_TRUE;
 
     nsCOMPtr<nsIDOMEventListener> listener;
     QueryInterface(NS_GET_IID(nsIDOMEventListener), getter_AddRefs(listener));
@@ -6578,17 +6614,23 @@ nsresult nsPluginInstanceOwner::Init(nsP
     target->AddEventListener(NS_LITERAL_STRING("keydown"), listener, PR_TRUE);
     target->AddEventListener(NS_LITERAL_STRING("keyup"), listener, PR_TRUE);
 
-    // Register drag listener
-    target->AddEventListener(NS_LITERAL_STRING("drop"), listener, PR_TRUE);
-    target->AddEventListener(NS_LITERAL_STRING("dragdrop"), listener, PR_TRUE);
-    target->AddEventListener(NS_LITERAL_STRING("drag"), listener, PR_TRUE);
-    target->AddEventListener(NS_LITERAL_STRING("dragenter"), listener, PR_TRUE);
-    target->AddEventListener(NS_LITERAL_STRING("dragover"), listener, PR_TRUE);
-    target->AddEventListener(NS_LITERAL_STRING("dragleave"), listener, PR_TRUE);
-    target->AddEventListener(NS_LITERAL_STRING("dragexit"), listener, PR_TRUE);
-    target->AddEventListener(NS_LITERAL_STRING("dragstart"), listener, PR_TRUE);
-    target->AddEventListener(NS_LITERAL_STRING("draggesture"), listener, PR_TRUE);
-    target->AddEventListener(NS_LITERAL_STRING("dragend"), listener, PR_TRUE);
+    if (!mContent->AttrValueIs(kNameSpaceID_None,
+                               nsGkAtoms::pluginHandlesDragEvents,
+                               nsGkAtoms::_false,
+                               eCaseMatters)) {
+      // Register drag listener
+      mPluginHandlesDragEvents = PR_TRUE;
+      target->AddEventListener(NS_LITERAL_STRING("drop"), listener, PR_TRUE);
+      target->AddEventListener(NS_LITERAL_STRING("dragdrop"), listener, PR_TRUE);
+      target->AddEventListener(NS_LITERAL_STRING("drag"), listener, PR_TRUE);
+      target->AddEventListener(NS_LITERAL_STRING("dragenter"), listener, PR_TRUE);
+      target->AddEventListener(NS_LITERAL_STRING("dragover"), listener, PR_TRUE);
+      target->AddEventListener(NS_LITERAL_STRING("dragleave"), listener, PR_TRUE);
+      target->AddEventListener(NS_LITERAL_STRING("dragexit"), listener, PR_TRUE);
+      target->AddEventListener(NS_LITERAL_STRING("dragstart"), listener, PR_TRUE);
+      target->AddEventListener(NS_LITERAL_STRING("draggesture"), listener, PR_TRUE);
+      target->AddEventListener(NS_LITERAL_STRING("dragend"), listener, PR_TRUE);
+    }
   }
   
   // Register scroll position listeners
