Index: /home/toddw/as/komodo-devel_moz7/mozilla/build/moz700-ko7.16/mozilla/layout/generic/nsObjectFrame.cpp
--- a/layout/generic/nsObjectFrame.cpp	Wed Aug 31 10:11:17 2011 -0400
+++ b/layout/generic/nsObjectFrame.cpp	Wed Aug 31 13:24:31 2011 -0700
@@ -538,14 +538,15 @@
     viewMan->SetViewVisibility(view, nsViewVisibility_kShow);
   }
 
   return (needsWidget && !canCreateWidget) ? NS_ERROR_NOT_AVAILABLE : NS_OK;
 }
 
-#define EMBED_DEF_WIDTH 240
-#define EMBED_DEF_HEIGHT 200
+// XXX ActiveState
+#define EMBED_DEF_WIDTH 20
+#define EMBED_DEF_HEIGHT 20
 
 /* virtual */ nscoord
 nsObjectFrame::GetMinWidth(nsRenderingContext *aRenderingContext)
 {
   nscoord result = 0;
 
@@ -836,12 +837,15 @@
   return rv;
 }
 
 PRBool
 nsObjectFrame::IsFocusable(PRInt32 *aTabIndex, PRBool aWithMouse)
 {
+  if (mInstanceOwner && !mInstanceOwner->AllowsFocus()) {
+    return PR_FALSE;
+  }
   if (aTabIndex)
     *aTabIndex = -1;
   return nsObjectFrameSuper::IsFocusable(aTabIndex, aWithMouse);
 }
 
 PRBool
Index: /home/toddw/as/komodo-devel_moz7/mozilla/build/moz700-ko7.16/mozilla/dom/plugins/base/nsPluginInstanceOwner.h
--- a/dom/plugins/base/nsPluginInstanceOwner.h	Wed Aug 31 10:11:17 2011 -0400
+++ b/dom/plugins/base/nsPluginInstanceOwner.h	Wed Aug 31 13:24:58 2011 -0700
@@ -294,12 +294,17 @@
   void SetBackgroundUnknown();
   already_AddRefed<gfxContext> BeginUpdateBackground(const nsIntRect& aRect);
   void EndUpdateBackground(gfxContext* aContext, const nsIntRect& aRect);
   
   PRBool UseAsyncRendering();
   
+  PRBool AllowsFocus()
+  {
+    return mPluginAllowsFocus;
+  }
+
 private:
   
   // return FALSE if LayerSurface dirty (newly created and don't have valid plugin content yet)
   PRBool IsUpToDate()
   {
     nsIntSize size;
@@ -350,12 +355,15 @@
 #endif
   PRPackedBool                mPluginWindowVisible;
   
   // If true, destroy the widget on destruction. Used when plugin stop
   // is being delayed to a safer point in time.
   PRPackedBool                mDestroyWidget;
+  PRPackedBool                mPluginAllowsFocus;
+  PRPackedBool                mPluginHandlesDomEvents;
+  PRPackedBool                mPluginHandlesDragEvents;
   PRUint16          mNumCachedAttrs;
   PRUint16          mNumCachedParams;
   char              **mCachedAttrParamNames;
   char              **mCachedAttrParamValues;
   
 #ifdef XP_MACOSX
Index: /home/toddw/as/komodo-devel_moz7/mozilla/build/moz700-ko7.16/mozilla/dom/plugins/base/nsPluginInstanceOwner.cpp
--- a/dom/plugins/base/nsPluginInstanceOwner.cpp	Wed Aug 31 10:11:17 2011 -0400
+++ b/dom/plugins/base/nsPluginInstanceOwner.cpp	Wed Aug 31 13:25:28 2011 -0700
@@ -314,12 +314,15 @@
   mPluginWindowVisible = PR_FALSE;
   mNumCachedAttrs = 0;
   mNumCachedParams = 0;
   mCachedAttrParamNames = nsnull;
   mCachedAttrParamValues = nsnull;
   mDestroyWidget = PR_FALSE;
+  mPluginAllowsFocus = PR_TRUE;
+  mPluginHandlesDomEvents = PR_FALSE;
+  mPluginHandlesDragEvents = PR_FALSE;
 
 #ifdef XP_MACOSX
 #ifndef NP_NO_QUICKDRAW
   mEventModel = NPEventModelCarbon;
 #else
   mEventModel = NPEventModelCocoa;
@@ -2140,14 +2143,21 @@
   }
 
   if ((response == kNPEventHandled || response == kNPEventStartIME) &&
       !(anEvent.eventStructType == NS_MOUSE_EVENT &&
         anEvent.message == NS_MOUSE_BUTTON_DOWN &&
         static_cast<const nsMouseEvent&>(anEvent).button == nsMouseEvent::eLeftButton &&
-        !mContentFocused))
+        !mContentFocused)) {
     rv = nsEventStatus_eConsumeNoDefault;
+  } else {
+    /* KOMODO: For the Mac, we want the plugin to determine what happens to
+               this event, whether this event is consumed or not
+     */
+    rv = (response == kNPEventNotHandled) ? nsEventStatus_eIgnore :
+                                            nsEventStatus_eConsumeNoDefault;
+  }
 
   pluginWidget->EndDrawPlugin();
 #endif
 
 #ifdef XP_WIN
   // this code supports windowless plugins
@@ -2508,13 +2518,13 @@
   if (mCXMenuListener) {
     mCXMenuListener->Destroy(mContent);
     mCXMenuListener = nsnull;
   }
 
   nsCOMPtr<nsIDOMEventTarget> target(do_QueryInterface(mContent));
-  if (target) {
+  if (target && mPluginHandlesDomEvents) {
 
     nsCOMPtr<nsIDOMEventListener> listener;
     QueryInterface(NS_GET_IID(nsIDOMEventListener), getter_AddRefs(listener));
 
     // Unregister focus event listener
     mContent->RemoveEventListenerByIID(listener, NS_GET_IID(nsIDOMFocusListener));
@@ -2527,23 +2537,25 @@
 
     // Unregister key event listener;
     target->RemoveEventListener(NS_LITERAL_STRING("keypress"), listener, PR_TRUE);
     target->RemoveEventListener(NS_LITERAL_STRING("keydown"), listener, PR_TRUE);
     target->RemoveEventListener(NS_LITERAL_STRING("keyup"), listener, PR_TRUE);
 
-    // Unregister drag event listener;
-    target->RemoveEventListener(NS_LITERAL_STRING("drop"), listener, PR_TRUE);
-    target->RemoveEventListener(NS_LITERAL_STRING("dragdrop"), listener, PR_TRUE);
-    target->RemoveEventListener(NS_LITERAL_STRING("drag"), listener, PR_TRUE);
-    target->RemoveEventListener(NS_LITERAL_STRING("dragenter"), listener, PR_TRUE);
-    target->RemoveEventListener(NS_LITERAL_STRING("dragover"), listener, PR_TRUE);
-    target->RemoveEventListener(NS_LITERAL_STRING("dragexit"), listener, PR_TRUE);
-    target->RemoveEventListener(NS_LITERAL_STRING("dragleave"), listener, PR_TRUE);
-    target->RemoveEventListener(NS_LITERAL_STRING("dragstart"), listener, PR_TRUE);
-    target->RemoveEventListener(NS_LITERAL_STRING("draggesture"), listener, PR_TRUE);
-    target->RemoveEventListener(NS_LITERAL_STRING("dragend"), listener, PR_TRUE);
+    if (mPluginHandlesDragEvents) {
+      // Unregister drag event listener;
+      target->RemoveEventListener(NS_LITERAL_STRING("drop"), listener, PR_TRUE);
+      target->RemoveEventListener(NS_LITERAL_STRING("dragdrop"), listener, PR_TRUE);
+      target->RemoveEventListener(NS_LITERAL_STRING("drag"), listener, PR_TRUE);
+      target->RemoveEventListener(NS_LITERAL_STRING("dragenter"), listener, PR_TRUE);
+      target->RemoveEventListener(NS_LITERAL_STRING("dragover"), listener, PR_TRUE);
+      target->RemoveEventListener(NS_LITERAL_STRING("dragexit"), listener, PR_TRUE);
+      target->RemoveEventListener(NS_LITERAL_STRING("dragleave"), listener, PR_TRUE);
+      target->RemoveEventListener(NS_LITERAL_STRING("dragstart"), listener, PR_TRUE);
+      target->RemoveEventListener(NS_LITERAL_STRING("draggesture"), listener, PR_TRUE);
+      target->RemoveEventListener(NS_LITERAL_STRING("dragend"), listener, PR_TRUE);
+    }
   }
 
   if (mWidget) {
     nsCOMPtr<nsIPluginWidget> pluginWidget = do_QueryInterface(mWidget);
     if (pluginWidget)
       pluginWidget->SetPluginInstanceOwner(nsnull);
@@ -2969,13 +2981,24 @@
   mCXMenuListener = new nsPluginDOMContextMenuListener();
   if (mCXMenuListener) {    
     mCXMenuListener->Init(aContent);
   }
 
   nsCOMPtr<nsIDOMEventTarget> target(do_QueryInterface(mContent));
-  if (target) {
+  if (target && mContent->AttrValueIs(kNameSpaceID_None,
+                                      nsGkAtoms::pluginAllowsFocusEvents,
+                                      nsGkAtoms::_false,
+                                      eCaseMatters)) {
+    mPluginAllowsFocus = PR_FALSE;
+  }
+
+  if (target && !mContent->AttrValueIs(kNameSpaceID_None,
+                                       nsGkAtoms::pluginHandlesDomEvents,
+                                       nsGkAtoms::_false,
+                                       eCaseMatters)) {
+    mPluginHandlesDomEvents = PR_TRUE;
 
     nsCOMPtr<nsIDOMEventListener> listener;
     QueryInterface(NS_GET_IID(nsIDOMEventListener), getter_AddRefs(listener));
 
     // Register focus listener
     mContent->AddEventListenerByIID(listener, NS_GET_IID(nsIDOMFocusListener));
@@ -2988,23 +3011,29 @@
 
     // Register key listener
     target->AddEventListener(NS_LITERAL_STRING("keypress"), listener, PR_TRUE);
     target->AddEventListener(NS_LITERAL_STRING("keydown"), listener, PR_TRUE);
     target->AddEventListener(NS_LITERAL_STRING("keyup"), listener, PR_TRUE);
 
-    // Register drag listener
-    target->AddEventListener(NS_LITERAL_STRING("drop"), listener, PR_TRUE);
-    target->AddEventListener(NS_LITERAL_STRING("dragdrop"), listener, PR_TRUE);
-    target->AddEventListener(NS_LITERAL_STRING("drag"), listener, PR_TRUE);
-    target->AddEventListener(NS_LITERAL_STRING("dragenter"), listener, PR_TRUE);
-    target->AddEventListener(NS_LITERAL_STRING("dragover"), listener, PR_TRUE);
-    target->AddEventListener(NS_LITERAL_STRING("dragleave"), listener, PR_TRUE);
-    target->AddEventListener(NS_LITERAL_STRING("dragexit"), listener, PR_TRUE);
-    target->AddEventListener(NS_LITERAL_STRING("dragstart"), listener, PR_TRUE);
-    target->AddEventListener(NS_LITERAL_STRING("draggesture"), listener, PR_TRUE);
-    target->AddEventListener(NS_LITERAL_STRING("dragend"), listener, PR_TRUE);
+    if (!mContent->AttrValueIs(kNameSpaceID_None,
+                               nsGkAtoms::pluginHandlesDragEvents,
+                               nsGkAtoms::_false,
+                               eCaseMatters)) {
+      // Register drag listener
+      mPluginHandlesDragEvents = PR_TRUE;
+      target->AddEventListener(NS_LITERAL_STRING("drop"), listener, PR_TRUE);
+      target->AddEventListener(NS_LITERAL_STRING("dragdrop"), listener, PR_TRUE);
+      target->AddEventListener(NS_LITERAL_STRING("drag"), listener, PR_TRUE);
+      target->AddEventListener(NS_LITERAL_STRING("dragenter"), listener, PR_TRUE);
+      target->AddEventListener(NS_LITERAL_STRING("dragover"), listener, PR_TRUE);
+      target->AddEventListener(NS_LITERAL_STRING("dragleave"), listener, PR_TRUE);
+      target->AddEventListener(NS_LITERAL_STRING("dragexit"), listener, PR_TRUE);
+      target->AddEventListener(NS_LITERAL_STRING("dragstart"), listener, PR_TRUE);
+      target->AddEventListener(NS_LITERAL_STRING("draggesture"), listener, PR_TRUE);
+      target->AddEventListener(NS_LITERAL_STRING("dragend"), listener, PR_TRUE);
+    }
   }
   
   // Register scroll position listeners
   // We need to register a scroll position listener on every scrollable
   // frame up to the top
   for (nsIFrame* f = mObjectFrame; f; f = nsLayoutUtils::GetCrossDocParentFrame(f)) {
