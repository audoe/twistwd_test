# HG changeset patch
# Parent 39a85ddd4222907aa8a8d0f2e7f6c5fc1d49b11f
# User marky
# Date 1300401525 25200
bug 642332: addon manager: expose as xpcom interface

diff --git a/toolkit/mozapps/extensions/Makefile.in b/toolkit/mozapps/extensions/Makefile.in
--- a/toolkit/mozapps/extensions/Makefile.in
+++ b/toolkit/mozapps/extensions/Makefile.in
@@ -75,6 +75,8 @@ EXTRA_JS_MODULES = \
   LightweightThemeManager.jsm \
   $(NULL)
 
+DIRS += xpcom
+
 ifdef ENABLE_TESTS
 DIRS += test
 endif
diff --git a/toolkit/mozapps/extensions/XPIProvider.jsm b/toolkit/mozapps/extensions/XPIProvider.jsm
--- a/toolkit/mozapps/extensions/XPIProvider.jsm
+++ b/toolkit/mozapps/extensions/XPIProvider.jsm
@@ -6807,6 +6807,7 @@ function AddonWrapper(aAddon) {
 
   this.hasResource = function(aPath) {
     let bundle = aAddon._sourceBundle.clone();
+    if (!bundle.exists()) return false;
 
     if (bundle.isDirectory()) {
       if (aPath) {
@@ -6827,6 +6828,7 @@ function AddonWrapper(aAddon) {
 
   this.getResourceURI = function(aPath) {
     let bundle = aAddon._sourceBundle.clone();
+    if (!bundle.exists()) return null;
 
     if (bundle.isDirectory()) {
       if (aPath) {
diff --git a/toolkit/mozapps/extensions/test/Makefile.in b/toolkit/mozapps/extensions/test/Makefile.in
--- a/toolkit/mozapps/extensions/test/Makefile.in
+++ b/toolkit/mozapps/extensions/test/Makefile.in
@@ -60,6 +60,7 @@ endif
 XPCSHELL_TESTS = \
   xpcshell \
   xpcshell-unpack \
+  xpcshell-xpcom \
   $(NULL)
 
 include $(topsrcdir)/config/rules.mk
@@ -75,4 +76,5 @@ libs::
 		done \
 	fi
 	cd $(TESTROOT)/xpcshell/ && tar -cPf - . | (cd $(TESTROOT)/xpcshell-unpack && tar -xPvf - )
+	cd $(TESTROOT)/xpcshell/ && tar -cPf - . | (cd $(TESTROOT)/xpcshell-xpcom && tar -xPvf - )
 
diff --git a/toolkit/mozapps/extensions/test/xpcshell-xpcom/head_xpcom.js b/toolkit/mozapps/extensions/test/xpcshell-xpcom/head_xpcom.js
new file mode 100644
--- /dev/null
+++ b/toolkit/mozapps/extensions/test/xpcshell-xpcom/head_xpcom.js
@@ -0,0 +1,385 @@
+Components.utils.import("resource://gre/modules/XPCOMUtils.jsm");
+Components.utils.import("resource://gre/modules/Services.jsm");
+
+Services.prefs.setBoolPref("extensions.logging.enabled", true);
+
+__defineGetter__("AddonManager", function() {
+    const Cc = Components.classes;
+    const Ci = Components.interfaces;
+    
+    delete this.AddonManager;
+
+    // jsAddon and jsAddonInstall caches, keyed by addon.id
+    var gAddonCache = {};
+    var gAddonInstallCache = [];
+    var gAddonListenerCache = [];
+    var gInstallListenerCache = [];
+    
+    /**
+     * Given a amIAddon, return a Addon (double-wrapped)
+     */
+    function jsAddon(addon) {
+        if (addon === null) return null;
+        if (addon.id in gAddonCache) {
+            for each (let [weak, js] in gAddonCache[addon.id]) {
+                let xpc = weak.get();
+                if (xpc == addon) {
+                    // re-use existing wrapped to get == equality
+                    return js;
+                }
+            }
+        } else {
+            gAddonCache[addon.id] = [];
+        }
+        var obj = {
+            _weak: Components.utils.getWeakReference(addon),
+            get _addon() this._weak.get(),
+            // we assume empty array is undefined instead since XPCOM can't
+            // pass null in place of an array...
+            get contributors()
+                this._addon.hasContributors ? this._addon.getContributors() : null,
+            get developers()
+                this._addon.hasDevelopers ? this._addon.getDevelopers() : null,
+            get translators()
+                this._addon.hasTranslators ? this._addon.getTranslators() : null,
+            get screenshots()
+                this._addon.getScreenshots().length ? this._addon.getScreenshots() : null,
+            get installDate()
+                new Date(this._addon.installDate / 1000),
+            get updateDate()
+                new Date(this._addon.updateDate / 1000),
+            get averageRating()
+                isNaN(this._addon.averageRating) ? null : this._addon.averageRating,
+            get reviewCount()
+                this._addon.reviewCount < 0 ? null : this._addon.reviewCount,
+            get totalDownloads()
+                this._addon.totalDownloads < 0 ? null : this._addon.totalDownloads,
+            get weeklyDownloads()
+                this._addon.weeklyDownloads < 0 ? null : this._addon.weeklyDownloads,
+            get dailyUsers()
+                this._addon.dailyUsers < 0 ? null : this._addon.dailyUsers,
+            get repositoryStatus()
+                this._addon.repositoryStatus < 0 ? null : this._addon.repositoryStatus,
+            get install() jsAddonInstall(this._addon.install),
+            get pendingUpgrade() jsAddon(this._addon.pendingUpgrade),
+            findUpdates: function(listener, reason, appVersion, platVersion) {
+                var xpcListener = xpcUpdateListener(listener)
+                return this._addon.findUpdates(xpcListener, reason,
+                                               appVersion, platVersion);
+            },
+            QueryInterface: XPCOMUtils.generateQI([Ci.amIAddon,
+                                                   Ci.nsISupportsWeakReference])
+        };
+        // don't use the proto chain since that causes cycles
+        for each (let p in Object.getOwnPropertyNames(addon)) {
+            if (p in obj) continue;
+            if (["hasContributors", "getContributors", "hasDevelopers",
+                 "getDevelopers", "getScreenshots", "hasTranslators",
+                 "getTranslators"].indexOf(p) != -1)
+            {
+                // unneeded; more JS-y version above
+                continue;
+            }
+            if (addon[p] instanceof Function) {
+                (function(func) {
+                    obj[func] = function()
+                        obj._addon[func].apply(obj._addon,
+                                               Array.slice(arguments));
+                })(p);
+            } else {
+                (function(prop){
+                    obj.__defineGetter__(prop, function() obj._addon[prop]);
+                    obj.__defineSetter__(prop, function(v) obj._addon[prop] = v);
+                })(p);
+            }
+        }
+        
+        gAddonCache[addon.id].push([obj._weak, obj]);
+        addon = null; // release ref
+        return obj;
+    }
+    
+    /**
+     * Given a amIAddonInstall, return a AddonInstall (double-wrapped)
+     */
+    function jsAddonInstall(wrapped) {
+        for each (let [weak, js] in gAddonInstallCache) {
+            let xpc = weak.get();
+            if (xpc == wrapped)
+                return js;
+        }
+        var obj = {
+            _weak: Components.utils.getWeakReference(wrapped),
+            get _install() this._weak.get(),
+            _listeners: [],
+
+            install: function() this._install.install(),
+            cancel: function() this._install.cancel(),
+            addListener: function(listener) {
+                if (this._listeners.some(function(x)x[1] == listener))
+                    return;
+                var wrappedListener = xpcInstallListener(listener);
+                this._listeners.push([wrappedListener, listener]);
+                this._install.addListener(wrappedListener);
+            },
+            removeListener: function(listener) {
+                this._listeners
+                    .filter(function(x)x[1] == listener)
+                    .forEach(function(x)obj._install.removeListener(x[0]));
+                this._listeners =
+                    this._listeners.filter(function(x)x[1] != listener);
+            },
+
+            get addon() jsAddon(this._install.addon),
+            get existingAddon() jsAddon(this._install.existingAddon),
+            get linkedInstalls() {
+                var links = this._install.getLinkedInstalls();
+                return links.length ? links : null;
+            }
+        };
+
+        // copy properties over; we can't just set the prototype since that
+        // creates a reference cycle across xpconnect boundaries
+        for each (let p in Object.getOwnPropertyNames(wrapped)) {
+            if (p in obj) continue;
+            if (wrapped[p] instanceof Function) {
+                (function(func) {
+                    obj[func] = function()
+                        obj._install[func].apply(obj._install,
+                                                 Array.slice(arguments));
+                })(p);
+            } else {
+                (function(prop){
+                    obj.__defineGetter__(prop, function() obj._install[prop]);
+                    obj.__defineSetter__(prop, function(v) obj._install[prop] = v);
+                })(p);
+            }
+        }
+        gAddonInstallCache.push([obj._weak, obj]);
+        wrapped = null; // break cycle
+        return obj;
+    }
+
+    /**
+     * Given a AddonCallback, return a amIAddonCallback
+     */
+    function xpcAddonCallback(callback)
+        callback && function(addon) callback(jsAddon(addon))
+
+    /**
+     * Given a AddonListCallback, return a amIAddonListCallback
+     */
+    function xpcAddonListCallback(callback)
+        callback && function(addons) callback(addons.map(jsAddon))
+    
+    /**
+     * Given a InstallCallback, return a amIInstallCallback
+     */
+    function xpcInstallCallback(callback)
+        callback && function(install) callback(jsAddonInstall(install))
+
+    /**
+     * Given a InstallListCallback, return a amIInstallListCallback
+     */
+    function xpcInstallListCallback(callback)
+        callback && function(installs) callback(installs.map(jsAddonInstall))
+    
+    function xpcUpdateListener(listener) listener && {
+            onCompatibilityUpdateAvailable: function(addon)
+                listener.onCompatibilityUpdateAvailable &&
+                    listener.onCompatibilityUpdateAvailable(jsAddon(addon)),
+            onNoCompatibilityUpdateAvailable: function(addon)
+                listener.onNoCompatibilityUpdateAvailable &&
+                    listener.onNoCompatibilityUpdateAvailable(jsAddon(addon)),
+            onUpdateAvailable: function(addon, install)
+                listener.onUpdateAvailable &&
+                    listener.onUpdateAvailable(jsAddon(addon),
+                                               jsAddonInstall(install)),
+            onNoUpdateAvailable: function(addon)
+                listener.onNoUpdateAvailable &&
+                    listener.onNoUpdateAvailable(jsAddon(addon)),
+            onUpdateFinished: function(addon, error)
+                listener.onUpdateFinished &&
+                    listener.onUpdateFinished(jsAddon(addon), error),
+            hasMethod: function(methodName)
+                methodName in listener,
+            QueryInterface: XPCOMUtils.generateQI([Ci.amIUpdateListener,
+                                                   Ci.nsISupportsWeakReference])
+        }
+    
+    function xpcAddonListener(listener) {
+        if (!listener) return listener;
+        for each (let [js, weak] in gAddonListenerCache) {
+            if (js == listener)
+                return weak.get();
+        }
+        var obj = {
+            onEnabling: function(addon, needsRestart)
+                listener.onEnabling &&
+                    listener.onEnabling(jsAddon(addon), needsRestart),
+            onEnabled: function(addon)
+                listener.onEnabled &&
+                    listener.onEnabled(jsAddon(addon)),
+            onDisabling: function(addon, needsRestart)
+                listener.onDisabling &&
+                    listener.onDisabling(jsAddon(addon), needsRestart),
+            onDisabled: function(addon)
+                listener.onDisabled &&
+                    listener.onDisabled(jsAddon(addon)),
+            onInstalling: function(addon, needsRestart)
+                listener.onInstalling &&
+                    listener.onInstalling(jsAddon(addon), needsRestart),
+            onInstalled: function(addon)
+                listener.onInstalled &&
+                    listener.onInstalled(jsAddon(addon)),
+            onUninstalling: function(addon, needsRestart)
+                listener.onUninstalling &&
+                    listener.onUninstalling(jsAddon(addon), needsRestart),
+            onUninstalled: function(addon)
+                listener.onUninstalled &&
+                    listener.onUninstalled(jsAddon(addon)),
+            onOperationCancelled: function(addon)
+                listener.onOperationCancelled &&
+                    listener.onOperationCancelled(jsAddon(addon)),
+            onPropertyChanged: function(addon, properties)
+                listener.onPropertyChanged &&
+                    listener.onPropertyChanged(jsAddon(onPropertyChanged),
+                                               properties),
+            QueryInterface: XPCOMUtils.generateQI([Ci.amIAddonListener,
+                                                   Ci.nsISupportsWeakReference])
+        }
+        gAddonListenerCache.push([listener,
+                                  Components.utils.getWeakReference(obj)]);
+        return obj;
+    }
+    
+    function xpcInstallListener(listener) {
+        if (!listener) return listener;
+        for each (let [js, weak] in gInstallListenerCache) {
+            if (js == listener)
+                return weak.get();
+        }
+        var obj = {
+            wrappedJSObject: listener,
+            onNewInstall: function(install)
+                listener.onNewInstall
+                    ? listener.onNewInstall(jsAddonInstall(install)) !== false
+                    : true,
+            onDownloadStarted: function(install)
+                listener.onDownloadStarted
+                    ? listener.onDownloadStarted(jsAddonInstall(install)) !== false
+                    : true,
+            onDownloadProgress: function(install)
+                listener.onDownloadProgress 
+                    ? listener.onDownloadProgress(jsAddonInstall(install)) !== false
+                    : true,
+            onDownloadEnded: function(install)
+                listener.onDownloadEnded
+                    ? listener.onDownloadEnded(jsAddonInstall(install)) !== false
+                    : true,
+            onDownloadCancelled: function(install)
+                listener.onDownloadCancelled
+                    ? listener.onDownloadCancelled(jsAddonInstall(install)) !== false
+                    : true,
+            onDownloadFailed: function(install)
+                listener.onDownloadFailed
+                    ? listener.onDownloadFailed(jsAddonInstall(install)) !== false
+                    : true,
+            onInstallStarted: function(install)
+                listener.onInstallStarted
+                    ? listener.onInstallStarted(jsAddonInstall(install)) !== false
+                    : true,
+            onInstallEnded: function(install, addon)
+                listener.onInstallEnded
+                    ? listener.onInstallEnded(jsAddonInstall(install),
+                                              jsAddon(addon)) !== false
+                    : true,
+            onInstallCancelled: function(install)
+                listener.onInstallCancelled
+                    ? listener.onInstallCancelled(jsAddonInstall(install)) !== false
+                    : true,
+            onInstallFailed: function(install)
+                listener.onInstallFailed
+                    ? listener.onInstallFailed(jsAddonInstall(install)) !== false
+                    : true,
+            onExternalInstall: function(addon, existingAddon, needsRestart)
+                listener.onExternalInstall
+                    ? listener.onExternalInstall(jsAddon(addon),
+                                                 jsAddon(existingAddon),
+                                                 needsRestart) !== false
+                    : true,
+            QueryInterface: XPCOMUtils.generateQI([Ci.amIInstallListener,
+                                                   Ci.nsISupportsWeakReference])
+        };
+        gInstallListenerCache.push([listener,
+                                    Components.utils.getWeakReference(obj)]);
+        return obj;
+    }
+
+
+    function service()
+        Cc["@mozilla.org/addons/addon-manager;1"].getService(Ci.amIAddonManager)
+
+    this.AddonManager = {
+        getInstallForURL: function(url, callback, mimetype, hash, name, iconURL,
+                                   version, loadGroup)
+            service().getInstallForURL(url, xpcInstallCallback(callback),
+                                       mimetype, hash, name, iconURL, version,
+                                       loadGroup),
+        getInstallForFile: function(file, callback, mimetype)
+            service().getInstallForFile(file, xpcInstallCallback(callback),
+                                        mimetype),
+        getAllInstalls: function(callback)
+            service().getAllInstalls(xpcInstallListCallback(callback)),
+        getInstallsByTypes: function(types, callback)
+            types
+                ? service().getInstallsByTypes(types,
+                                               xpcInstallListCallback(callback),
+                                               types.length)
+                : service().getAllInstalls(xpcInstallListCallback(callback)),
+        installAddonsFromWebpage: function(mimetype, source, uri, installs)
+            service().installAddonsFromWebpage(mimetype, source, uri, installs,
+                                               installs.length),
+        addInstallListener: function(listener)
+            service().addInstallListener(xpcInstallListener(listener)),
+        removeInstallListener: function(listener)
+            service().removeInstallListener(xpcInstallListener(listener)),
+        getAllAddons: function(callback)
+            service().getAllAddons(xpcAddonListCallback(callback)),
+        getAddonByID: function(id, callback)
+            service().getAddonByID(id, xpcAddonCallback(callback)),
+        getAddonsByIDs: function(ids, callback)
+            service().getAddonsByIDs(ids, xpcAddonListCallback(callback),
+                                     ids.length),
+        getAddonsByTypes: function(types, callback)
+            types
+                ? service().getAddonsByTypes(types,
+                                             xpcAddonListCallback(callback),
+                                             types.length)
+                : this.getAllAddons(callback),
+        getAddonsWithOperationsByTypes: function(types, callback)
+            service().getAddonsWithOperationsByTypes(types || [],
+                                                     xpcAddonListCallback(callback),
+                                                     types ? types.length : 0),
+        addAddonListener: function(listener)
+            service().addAddonListener(xpcAddonListener(listener)),
+        removeAddonListener: function(listener)
+            service().removeAddonListener(xpcAddonListener(listener))
+    };
+
+    for each (let func in ["isInstallAllowed", "isInstallEnabled"]) {
+        (function(func){
+            this.AddonManager[func] = function()
+                service()[func].apply(service(), Array.slice(arguments));
+        })(func);
+    }
+    // copy constants over
+    for (let prop in service()) {
+        if (/^[A-Z_]+$/.test(prop)) {
+            this.AddonManager[prop] = service()[prop];
+        }
+    }
+
+    Object.freeze(this.AddonManager);
+    return this.AddonManager;
+});
diff --git a/toolkit/mozapps/extensions/test/xpcshell/test_bootstrap.js b/toolkit/mozapps/extensions/test/xpcshell/test_bootstrap.js
--- a/toolkit/mozapps/extensions/test/xpcshell/test_bootstrap.js
+++ b/toolkit/mozapps/extensions/test/xpcshell/test_bootstrap.js
@@ -1067,6 +1067,7 @@ function run_test_23() {
       do_check_eq(install.version, "1.0");
       do_check_eq(install.name, "Test Bootstrap 1");
       do_check_eq(install.state, AddonManager.STATE_DOWNLOADED);
+      do_check_neq(install.addon, null);
       do_check_true(install.addon.hasResource("install.rdf"));
       do_check_true(install.addon.hasResource("bootstrap.js"));
       do_check_false(install.addon.hasResource("foo.bar"));
diff --git a/toolkit/mozapps/extensions/test/xpcshell/test_cacheflush.js b/toolkit/mozapps/extensions/test/xpcshell/test_cacheflush.js
--- a/toolkit/mozapps/extensions/test/xpcshell/test_cacheflush.js
+++ b/toolkit/mozapps/extensions/test/xpcshell/test_cacheflush.js
@@ -67,6 +67,7 @@ function run_test_2() {
 
     AddonManager.getAddonByID("addon1@tests.mozilla.org", function(a1) {
       // We should flush the installed XPI when uninstalling
+      do_check_true(a1.isActive);
       gExpectedFile = gProfD.clone();
       gExpectedFile.append("extensions");
       gExpectedFile.append("addon1@tests.mozilla.org.xpi");
diff --git a/toolkit/mozapps/extensions/test/xpcshell/test_getresource.js b/toolkit/mozapps/extensions/test/xpcshell/test_getresource.js
--- a/toolkit/mozapps/extensions/test/xpcshell/test_getresource.js
+++ b/toolkit/mozapps/extensions/test/xpcshell/test_getresource.js
@@ -43,6 +43,7 @@ function run_test() {
         let rootUri = do_get_addon_root_uri(addonDir, "addon1@tests.mozilla.org");
 
         let uri = a1.getResourceURI("/");
+        do_check_neq(uri, null);
         do_check_eq(uri.spec, rootUri);
 
         let file = rootUri + "install.rdf";
diff --git a/toolkit/mozapps/extensions/test/xpcshell/test_plugins.js b/toolkit/mozapps/extensions/test/xpcshell/test_plugins.js
--- a/toolkit/mozapps/extensions/test/xpcshell/test_plugins.js
+++ b/toolkit/mozapps/extensions/test/xpcshell/test_plugins.js
@@ -61,7 +61,7 @@ function run_test_1() {
   var testPlugin = get_test_plugin();
   do_check_neq(testPlugin, null);
 
-  AddonManager.getAddonsByTypes("plugin", function(addons) {
+  AddonManager.getAddonsByTypes(["plugin"], function(addons) {
     do_check_true(addons.length > 0);
 
     addons.forEach(function(p) {
diff --git a/toolkit/mozapps/extensions/test/xpcshell/test_update.js b/toolkit/mozapps/extensions/test/xpcshell/test_update.js
--- a/toolkit/mozapps/extensions/test/xpcshell/test_update.js
+++ b/toolkit/mozapps/extensions/test/xpcshell/test_update.js
@@ -167,6 +167,8 @@ function check_test_1(install) {
 function run_test_2(install) {
   // Verify that another update check returns no new update
   install.existingAddon.findUpdates({
+    _triggered: false,
+
     onNoCompatibilityUpdateAvailable: function(addon) {
       do_throw("Should not have seen onNoCompatibilityUpdateAvailable notification");
     },
@@ -176,6 +178,7 @@ function run_test_2(install) {
     },
 
     onNoUpdateAvailable: function(addon) {
+      this._triggered = true;
       AddonManager.getAllInstalls(function(aInstalls) {
         do_check_eq(aInstalls.length, 1);
         do_check_eq(aInstalls[0], install);
@@ -190,6 +193,10 @@ function run_test_2(install) {
         ], check_test_2);
         install.install();
       });
+    },
+    
+    onUpdateFinished: function(addon, error) {
+      do_check_true(this._triggered);
     }
   }, AddonManager.UPDATE_WHEN_USER_REQUESTED);
 }
diff --git a/toolkit/mozapps/extensions/test/xpcshell/test_updateid.js b/toolkit/mozapps/extensions/test/xpcshell/test_updateid.js
--- a/toolkit/mozapps/extensions/test/xpcshell/test_updateid.js
+++ b/toolkit/mozapps/extensions/test/xpcshell/test_updateid.js
@@ -77,13 +77,18 @@ function run_test_1() {
     do_check_eq(a1.version, "1.0");
 
     a1.findUpdates({
+      _hasUpdate: false,
       onUpdateAvailable: function(addon, install) {
+        this._hasUpdate = true;
         do_check_eq(install.name, addon.name);
         do_check_eq(install.version, "2.0");
         do_check_eq(install.state, AddonManager.STATE_AVAILABLE);
         do_check_eq(install.existingAddon, a1);
 
         installUpdate(install, check_test_1);
+      },
+      onUpdateFinished: function(addon, error) {
+        do_check_true(this._hasUpdate);
       }
     }, AddonManager.UPDATE_WHEN_USER_REQUESTED);
   });
@@ -145,8 +150,13 @@ function run_test_2() {
     do_check_eq(a1.version, "1.0");
 
     a1.findUpdates({
+      _hasUpdate: false,
       onUpdateAvailable: function(addon, install) {
+        this._hasUpdate = true;
         installUpdate(install, check_test_2);
+      },
+      onUpdateFinished: function(addon, error) {
+        do_check_true(this._hasUpdate);
       }
     }, AddonManager.UPDATE_WHEN_USER_REQUESTED);
   });
@@ -207,8 +217,13 @@ function run_test_3() {
     do_check_eq(a1.version, "1.0");
 
     a1.findUpdates({
+      _hasUpdate: false,
       onUpdateAvailable: function(addon, install) {
+        this._hasUpdate = true;
         installUpdate(install, check_test_3);
+      },
+      onUpdateFinished: function(addon, error) {
+        do_check_true(this._hasUpdate);
       }
     }, AddonManager.UPDATE_WHEN_USER_REQUESTED);
   });
diff --git a/toolkit/mozapps/extensions/xpcom/Makefile.in b/toolkit/mozapps/extensions/xpcom/Makefile.in
new file mode 100644
--- /dev/null
+++ b/toolkit/mozapps/extensions/xpcom/Makefile.in
@@ -0,0 +1,60 @@
+# ***** BEGIN LICENSE BLOCK *****
+# Version: MPL 1.1/GPL 2.0/LGPL 2.1
+#
+# The contents of this file are subject to the Mozilla Public License Version
+# 1.1 (the "License"); you may not use this file except in compliance with
+# the License. You may obtain a copy of the License at
+# http://www.mozilla.org/MPL/
+#
+# Software distributed under the License is distributed on an "AS IS" basis,
+# WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+# for the specific language governing rights and limitations under the
+# License.
+#
+# The Original Code is Extension Manager.
+#
+# The Initial Developer of the Original Code is
+#      Mook <marky+mozhg@activestate.com>
+#
+# Portions created by the Initial Developer are Copyright (C) 2011
+# the Initial Developer. All Rights Reserved.
+#
+# Contributor(s):
+#
+# Alternatively, the contents of this file may be used under the terms of
+# either of the GNU General Public License Version 2 or later (the "GPL"),
+# or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+# in which case the provisions of the GPL or the LGPL are applicable instead
+# of those above. If you wish to allow use of your version of this file only
+# under the terms of either the GPL or the LGPL, and not to allow others to
+# use your version of this file under the terms of the MPL, indicate your
+# decision by deleting the provisions above and replace them with the notice
+# and other provisions required by the GPL or the LGPL. If you do not delete
+# the provisions above, a recipient may use your version of this file under
+# the terms of any one of the MPL, the GPL or the LGPL.
+#
+# ***** END LICENSE BLOCK *****
+
+DEPTH = ../../../..
+topsrcdir = @top_srcdir@
+srcdir = @srcdir@
+VPATH = @srcdir@
+
+include $(DEPTH)/config/autoconf.mk
+
+XPIDL_MODULE   = addon_manager
+
+XPIDLSRCS = \
+    amIAddon.idl \
+    amIAddonListener.idl \
+    amIAddonInstall.idl \
+    amIAddonManager.idl \
+    amIInstallListener.idl \
+    amIUpdateListener.idl \
+    $(NULL)
+
+EXTRA_COMPONENTS = \
+  addon-manager-xpcom.manifest \
+  amAddonManager.js \
+
+include $(topsrcdir)/config/rules.mk
diff --git a/toolkit/mozapps/extensions/xpcom/addon-manager-xpcom.manifest b/toolkit/mozapps/extensions/xpcom/addon-manager-xpcom.manifest
new file mode 100644
--- /dev/null
+++ b/toolkit/mozapps/extensions/xpcom/addon-manager-xpcom.manifest
@@ -0,0 +1,2 @@
+component {15f8ee3a-1b7f-43c8-bdd9-6add07b52e1d} amAddonManager.js
+contract @mozilla.org/addons/addon-manager;1 {15f8ee3a-1b7f-43c8-bdd9-6add07b52e1d}
diff --git a/toolkit/mozapps/extensions/xpcom/amAddonManager.js b/toolkit/mozapps/extensions/xpcom/amAddonManager.js
new file mode 100644
--- /dev/null
+++ b/toolkit/mozapps/extensions/xpcom/amAddonManager.js
@@ -0,0 +1,351 @@
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is AddonManager XPCOM wrapper.
+ *
+ * The Initial Developer of the Original Code is
+ * Mook <marky+mozhg@activestate.com>.
+ * Portions created by the Initial Developer are Copyright (C) 2011
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+
+const Ci = Components.interfaces;
+const Cu = Components.utils;
+
+Cu.import("resource://gre/modules/XPCOMUtils.jsm");
+Cu.import("resource://gre/modules/AddonManager.jsm");
+
+["LOG", "WARN", "ERROR"].forEach(function(aName) {
+  this.__defineGetter__(aName, function() {
+    Components.utils.import("resource://gre/modules/AddonLogging.jsm");
+
+    LogManager.getLogger("addons.xpcom", this);
+    return this[aName];
+  });
+}, this);
+
+var gAddonCache = {};
+var gAddonInstallCache = [];
+var gAddonInstallListenerCache = [];
+var gAddonListenerCache = [];
+var gUpdateListenerCache = [];
+
+function getCachedValue(cache, item, wrapped) {
+    var weak = null;
+    if (item instanceof Ci.nsISupports) {
+        if (item.wrappedJSObject) {
+            item = item.wrappedJSObject;
+        } else {
+            weak = Components.utils.getWeakReference(item);
+        }
+    }
+    for each (let entry in cache) {
+        var ref = (entry[0] instanceof Ci.xpcIJSWeakReference) ? entry[0].get()
+                                                               : entry[0];
+        if (ref === item) {
+            return entry[1];
+        }
+    }
+    cache.push([weak || item, wrapped]);
+    return wrapped;
+}
+
+/**
+ * Given a Addon, return a amIAddon
+ */
+function xpcAddon(aAddon) {
+    if (!aAddon) return aAddon;
+    if (aAddon.id in gAddonCache) {
+        for each (let [js, xpc] in gAddonCache[aAddon.id])
+            if (js == aAddon)
+                return xpc;
+    } else {
+        // cache miss
+        gAddonCache[aAddon.id] = [];
+    }
+    var wrapped = {
+        findUpdates: function(listener, reason, appVersion, platformVersion)
+            aAddon.findUpdates(jsUpdateListener(listener), reason,
+                               appVersion, platformVersion),
+        get hasContributors() Array.isArray(aAddon.contributors),
+        getContributors: function(count) {
+            if (!aAddon.contributors) return null;
+            if (count) count.value = aAddon.contributors.length;
+            return aAddon.contributors;
+        },
+        get hasDevelopers() Array.isArray(aAddon.developers),
+        getDevelopers: function(count) {
+            if (!aAddon.developers) return null;
+            if (count) count.value = aAddon.developers.length;
+            return aAddon.developers;
+        },
+        get hasTranslators() Array.isArray(aAddon.translators),
+        getTranslators: function(count) {
+            if (!aAddon.translators) return null;
+            if (count) count.value = aAddon.translators.length;
+            return aAddon.translators;
+        },
+        getScreenshots: function(count) {
+            if (!aAddon.screenshots) return null;
+            if (count) count.value = aAddon.screenshots.length;
+            return aAddon.screenshots;
+        },
+        get installDate() aAddon.installDate.getTime() * 1000,
+        get updateDate() aAddon.updateDate.getTime() * 1000,
+        get install() xpcAddonInstall(aAddon.install),
+        get pendingUpgrade() xpcAddon(aAddon.pendingUpgrade),
+        get averageRating()
+            aAddon.averageRating === null ? NaN : aAddon.averageRating,
+        get reviewCount()
+            aAddon.reviewCount === null ? -1 : aAddon.reviewCount,
+        get totalDownloads()
+            aAddon.totalDownloads === null ? -1 : aAddon.totalDownloads,
+        get weeklyDownloads()
+            aAddon.reviewCount === null ? -1 : aAddon.weeklyDownloads,
+        get dailyUsers()
+            aAddon.reviewCount === null ? -1 : aAddon.dailyUsers,
+        get repositoryStatus()
+            aAddon.repositoryStatus === null ? -1 : aAddon.repositoryStatus,
+        QueryInterface: XPCOMUtils.generateQI([Ci.amIAddon,
+                                               Ci.nsISupportsWeakReference])
+    };
+    wrapped.__proto__ = aAddon;
+    gAddonCache[aAddon.id].push([aAddon, wrapped]);
+    return wrapped;
+}
+
+/**
+ * Given an AddonInstall, return a amIAddonInstall
+ */
+function xpcAddonInstall(aInstall) {
+    if (!aInstall) return aInstall;
+    var wrapped = {
+        __proto__: aInstall,
+        addListener: function(listener)
+            aInstall.addListener(jsInstallListener(listener)),
+        removeListener: function(listener)
+            aInstall.removeListener(jsInstallListener(listener)),
+        get existingAddon()
+            xpcAddon(aInstall.existingAddon),
+        get addon()
+            xpcAddon(aInstall.addon),
+        getLinkedInstalls: function(count) {
+            if (!wrapped.linkedInstalls)
+                return [];
+            if (count)
+                count.value = wrapped.linkedInstalls.length;
+            return [].concat(wrapped.linkedInstalls);
+        },
+        QueryInterface: XPCOMUtils.generateQI([Ci.amIAddonInstall,
+                                               Ci.nsISupportsWeakReference])
+    };
+    wrapped.wrappedJSObject = wrapped;
+    return getCachedValue(gAddonInstallCache, aInstall, wrapped);
+}
+
+/**
+ * Given a amIInstallListener, return a InstallListener
+ */
+function jsInstallListener(aListener) {
+    var wrapped = {
+        onNewInstall: function(install)
+            aListener.onNewInstall(xpcAddonInstall(install)),
+        onDownloadStarted: function(install)
+            aListener.onDownloadStarted(xpcAddonInstall(install)),
+        onDownloadProgress: function(install)
+            aListener.onDownloadProgress(xpcAddonInstall(install)),
+        onDownloadEnded: function(install)
+            aListener.onDownloadEnded(xpcAddonInstall(install)),
+        onDownloadCancelled: function(install)
+            aListener.onDownloadCancelled(xpcAddonInstall(install)),
+        onDownloadFailed: function(install)
+            aListener.onDownloadFailed(xpcAddonInstall(install)),
+        onInstallStarted: function(install)
+            aListener.onInstallStarted(xpcAddonInstall(install)),
+        onInstallEnded: function(install, addon)
+            aListener.onInstallEnded(xpcAddonInstall(install),
+                                     xpcAddon(addon)),
+        onInstallCancelled: function(install)
+            aListener.onInstallCancelled(xpcAddonInstall(install)),
+        onInstallFailed: function(install)
+            aListener.onInstallFailed(xpcAddonInstall(install)),
+        onExternalInstall: function(addon, existingAddon, restart)
+            aListener.onExternalInstall(xpcAddon(addon),
+                                        xpcAddon(existingAddon),
+                                        restart)
+    };
+    wrapped.wrappedJSObject = wrapped;
+    return getCachedValue(gAddonInstallListenerCache, aListener, wrapped);
+}
+
+/**
+ * Given a amIAddonListener, return a AddonListener
+ */
+function jsAddonListener(aListener) {
+    var wrapped = {
+        onEnabling: function(addon, restart)
+            aListener.onEnabling(xpcAddon(addon), restart),
+        onEnabled: function(addon)
+            aListener.onEnabled(xpcAddon(addon)),
+        onDisabling: function(addon, restart)
+            aListener.onDisabling(xpcAddon(addon), restart),
+        onDisabled: function(addon)
+            aListener.onDisabled(xpcAddon(addon)),
+        onInstalling: function(addon, restart)
+            aListener.onInstalling(xpcAddon(addon), restart),
+        onInstalled: function(addon)
+            aListener.onInstalled(xpcAddon(addon)),
+        onUninstalling: function(addon, restart)
+            aListener.onUninstalling(xpcAddon(addon), restart),
+        onUninstalled: function(addon)
+            aListener.onUninstalled(xpcAddon(addon)),
+        onOperationCancelled: function(addon)
+            aListener.onOperationCancelled(xpcAddon(addon)),
+        onPropertyChanged: function(addon, properties)
+            aListener.onPropertyChanged(xpcAddon(addon),
+                                        properties,
+                                        properties.length)
+    };
+    wrapped.wrappedJSObject = wrapped;
+    return getCachedValue(gAddonListenerCache, aListener, wrapped);
+}
+
+/**
+ * Given a amIUpdateListener, return a UpdateListener
+ */
+function jsUpdateListener(aListener) {
+    if (!aListener)
+        return aListener;
+    // the _existence_ of the methods gets checked (and different urls are
+    // being used for update checks), so we can't have no-op stubs
+    var wrapped = {};
+    if (aListener.hasMethod("onCompatibilityUpdateAvailable"))
+        wrapped.onCompatibilityUpdateAvailable = function(addon)
+            aListener.onCompatibilityUpdateAvailable(xpcAddon(addon));
+    if (aListener.hasMethod("onNoCompatibilityUpdateAvailable"))
+        wrapped.onNoCompatibilityUpdateAvailable = function(addon)
+            aListener.onNoCompatibilityUpdateAvailable(xpcAddon(addon));
+    if (aListener.hasMethod("onUpdateAvailable"))
+        wrapped.onUpdateAvailable = function(addon, install)
+            aListener.onUpdateAvailable(xpcAddon(addon), xpcAddonInstall(install));
+    if (aListener.hasMethod("onNoUpdateAvailable"))
+        wrapped.onNoUpdateAvailable = function(addon)
+            aListener.onNoUpdateAvailable(xpcAddon(addon));
+    if (aListener.hasMethod("onUpdateFinished"))
+        wrapped.onUpdateFinished = function(addon, error)
+            aListener.onUpdateFinished(xpcAddon(addon), error);
+    wrapped.wrappedJSObject = wrapped;
+    return getCachedValue(gUpdateListenerCache, aListener, wrapped);
+}
+
+/**
+ * Given a amIAddonCallback, return a AddonCallback
+ */
+function jsAddonCallback(callback)
+    callback && function(addon)
+        callback.AddonCallback(xpcAddon(addon))
+
+/**
+ * Given a amIAddonListCallback, return a AddonListCallback
+ */
+function jsAddonListCallback(callback)
+    callback && function(addons)
+        callback.AddonListCallback(addons.map(xpcAddon), addons.length)
+
+/**
+ * Given a amIInstallCallback, return a InstallCallback
+ */
+function jsInstallCallback(callback)
+    callback && function(install)
+        callback.InstallCallback(xpcAddonInstall(install))
+
+/**
+ * Given a amIInstallListCallback, return a InstallListCallback
+ */
+function jsInstallListCallback(callback)
+    callback && function(installs)
+        callback.InstallListCallback(installs.map(xpcAddonInstall),
+                                     installs.length)
+
+function amAddonManager() {
+    // there's no point exposing the wrapper to JS.
+    // (there's also no point getting the AddonManager via this service rather
+    // than the JS module, but whatever)
+    this.wrappedJSObject = AddonManager;
+}
+
+amAddonManager.prototype = {
+    getInstallForURL: function(url, callback, mimetype, hash, name, iconURL,
+                               version, loadGroup)
+        AddonManager.getInstallForURL(url, jsInstallCallback(callback),
+                                      mimetype, hash, name, iconURL,
+                                      version, loadGroup),
+    getInstallForFile: function(file, callback, mimetype)
+        AddonManager.getInstallForFile(file,
+                                       jsInstallCallback(callback),
+                                       mimetype),
+    getAllInstalls: function(callback)
+        AddonManager.getAllInstalls(jsInstallListCallback(callback)),
+    getInstallsByTypes: function(types, callback, typeCount)
+        AddonManager.getInstallsByTypes(types, jsInstallListCallback(callback)),
+    installAddonsFromWebpage: function()
+        AddonManager.installAddonsFromWebpage.apply(AddonManager, Array.slice(arguments)),
+    addInstallListener: function(listener)
+        AddonManager.addInstallListener(jsInstallListener(listener)),
+    removeInstallListener: function(listener)
+        AddonManager.removeInstallListener(jsInstallListener(listener)),
+    getAllAddons: function(callback)
+        AddonManager.getAllAddons(jsAddonListCallback(callback)),
+    getAddonByID: function(id, callback)
+        AddonManager.getAddonByID(id, jsAddonCallback(callback)),
+    getAddonsByIDs: function(ids, callback, idCount)
+        AddonManager.getAddonsByIDs(ids, jsAddonListCallback(callback)),
+    getAddonsByTypes: function(types, callback, typeCount)
+        AddonManager.getAddonsByTypes(types, jsAddonListCallback(callback)),
+    getAddonsWithOperationsByTypes: function(types, callback, typeCount)
+        AddonManager.getAddonsWithOperationsByTypes(types,
+                                                    jsAddonListCallback(callback)),
+    addAddonListener: function(listener)
+        AddonManager.addAddonListener(jsAddonListener(listener)),
+    removeAddonListener: function(listener)
+        AddonManager.removeAddonListener(jsAddonListener(listener)),
+    isInstallAllowed: function(mimetype, uri)
+        AddonManager.isInstallAllowed(mimetype, uri),
+    isInstallEnabled: function(mimetype)
+        AddonManager.isInstallEnabled(mimetype),
+
+    // properties required for XPCOM registration (unused, see manifest):
+    classDescription: "AddonManager XPCOM Wrapper",
+    classID:          Components.ID("{15f8ee3a-1b7f-43c8-bdd9-6add07b52e1d}"),
+    contractID:       "@mozilla.org/addons/addon-manager;1",
+    
+    QueryInterface: XPCOMUtils.generateQI([Ci.amIAddonManager])
+};
+
+const NSGetFactory = XPCOMUtils.generateNSGetFactory([amAddonManager]);
diff --git a/toolkit/mozapps/extensions/xpcom/amIAddon.idl b/toolkit/mozapps/extensions/xpcom/amIAddon.idl
new file mode 100644
--- /dev/null
+++ b/toolkit/mozapps/extensions/xpcom/amIAddon.idl
@@ -0,0 +1,139 @@
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is AddonManager XPCOM wrapper.
+ *
+ * The Initial Developer of the Original Code is
+ * Mook <marky+mozhg@activestate.com>.
+ * Portions created by the Initial Developer are Copyright (C) 2011
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#include "nsISupports.idl"
+
+/* XPCOM wrapper for AddonManager Addon
+ * @see https://developer.mozilla.org/en/Addons/Add-on_Manager/Addon
+ */
+
+interface amIAddon;
+interface amIAddonAuthor;
+interface amIAddonInstall;
+interface amIAddonScreenshot;
+interface amIUpdateListener;
+
+interface nsIURI;
+
+[scriptable, uuid(35ecb02a-b7db-49bc-89ba-c4b8152d3681)]
+interface amIAddon: nsISupports {
+    boolean isCompatibleWith([optional] in AUTF8String appVersion,
+                             [optional] in AUTF8String platformVersion);
+
+    void findUpdates(in amIUpdateListener listener,
+                     in long reason,
+                     [optional] in AUTF8String appVersion,
+                     [optional] in AUTF8String platformVersion);
+    void uninstall();
+    void cancelUninstall();
+    boolean hasResource([optional] in AUTF8String path);
+    nsIURI getResourceURI([optional] in AUTF8String path);
+
+    /* required attributes */
+    attribute boolean appDisabled;
+    attribute long blocklistState;
+    attribute amIAddonAuthor creator;
+    attribute AUTF8String id;
+    attribute boolean isActive;
+    attribute boolean isCompatible;
+    attribute boolean isPlatformCompatible;
+    attribute AUTF8String name;
+    attribute long pendingOperations;
+    attribute long permissions;
+    attribute boolean providesUpdatesSecurely;
+    attribute long scope;
+    attribute ACString type;
+    attribute boolean userDisabled;
+    attribute AUTF8String version;
+
+    /* optional attributes */
+    attribute AUTF8String aboutURL;
+    attribute long applyBackgroundUpdates;
+    readonly attribute boolean hasContributors;
+    void getContributors([optional] out unsigned long contributorCount,
+                         [retval, array, size_is(contributorCount)] out amIAddonAuthor contributors);
+    attribute AString description;
+    readonly attribute boolean hasDevelopers;
+    void getDevelopers([optional] out unsigned long developerCount,
+                       [retval, array, size_is(developerCount)] out amIAddonAuthor developers);
+    attribute AUTF8String homepageURL;
+    attribute AUTF8String iconURL;
+    attribute amIAddonInstall install;
+    attribute PRTime installDate;
+    attribute AUTF8String optionsURL;
+    attribute amIAddon pendingUpgrade;
+    attribute nsIURI releaseNotesURI;
+    void getScreenshots([optional] out unsigned long screenshotCount,
+                        [retval, array, size_is(screenshotCount)] out amIAddonScreenshot screenshots);
+    attribute unsigned long size;
+    attribute nsIURI sourceURI;
+    readonly attribute boolean hasTranslators;
+    void getTranslators([optional] out unsigned long translatorCount,
+                        [retval, array, size_is(translatorCount)] out amIAddonAuthor translators);
+    attribute PRTime updateDate;
+    attribute long operationsRequiringRestart;
+    // special undocumented things being tested for!
+    attribute AString fullDescription;
+    attribute AString developerComments;
+    attribute AString eula;
+    attribute AUTF8String icon64URL;
+    attribute AUTF8String supportURL;
+    attribute AUTF8String contributionURL;
+    attribute AUTF8String contributionAmount;
+    attribute double averageRating;
+    attribute long reviewCount;
+    attribute AUTF8String reviewURL;
+    attribute long totalDownloads;
+    attribute long weeklyDownloads;
+    attribute long dailyUsers;
+    attribute long repositoryStatus;
+    attribute boolean skinnable; // for themes only?
+};
+
+[scriptable, uuid(d0f5fa06-22cd-43e7-b68d-c759fca62787)]
+interface amIAddonAuthor: nsISupports {
+    attribute AString name;
+    attribute ACString url; /* optional */
+    AString toString();
+};
+
+[scriptable, uuid(161d45d2-0ce7-44c4-a9c6-1b2149bbbf67)]
+interface amIAddonScreenshot: nsISupports {
+    attribute AUTF8String url;
+    attribute AUTF8String thumbnailURL;
+    attribute AString caption;
+    AString toString();
+};
diff --git a/toolkit/mozapps/extensions/xpcom/amIAddonInstall.idl b/toolkit/mozapps/extensions/xpcom/amIAddonInstall.idl
new file mode 100644
--- /dev/null
+++ b/toolkit/mozapps/extensions/xpcom/amIAddonInstall.idl
@@ -0,0 +1,77 @@
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is AddonManager XPCOM wrapper.
+ *
+ * The Initial Developer of the Original Code is
+ * Mook <marky+mozhg@activestate.com>.
+ * Portions created by the Initial Developer are Copyright (C) 2011
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#include "nsISupports.idl"
+
+/* XPCOM wrapper for AddonManager AddonInstall
+ * @see https://developer.mozilla.org/en/Addons/Add-on_Manager/AddonInstall
+ */
+
+interface amIAddon;
+interface amIInstallListener;
+
+interface nsIFile;
+interface nsIURI;
+interface nsIX509Cert;
+
+[scriptable, uuid(a70387a0-f758-40dc-95ba-eef654082952)]
+interface amIAddonInstall: nsISupports {
+    void install();
+    void cancel();
+    void addListener(in amIInstallListener listener);
+    void removeListener(in amIInstallListener listener);
+
+    attribute AString name;
+    attribute AUTF8String version;
+    attribute AUTF8String iconURL;
+    attribute nsIURI releaseNotesURI;
+    attribute ACString type;
+    attribute long state;
+    attribute long error;
+    attribute nsIURI sourceURI;
+    attribute nsIFile file;
+    attribute long progress;
+    attribute long maxProgress;
+    attribute nsIX509Cert certificate;
+    attribute AString certName;
+    attribute amIAddon existingAddon;
+    attribute amIAddon addon;
+
+    // mysterious undocumented attributes
+    /* amIAddonInstall[] linkedInstalls */
+    void getLinkedInstalls([optional] out unsigned long linkedCount,
+                           [retval, array, size_is(linkedCount)] out amIAddonInstall linkedInstalls);
+};
diff --git a/toolkit/mozapps/extensions/xpcom/amIAddonListener.idl b/toolkit/mozapps/extensions/xpcom/amIAddonListener.idl
new file mode 100644
--- /dev/null
+++ b/toolkit/mozapps/extensions/xpcom/amIAddonListener.idl
@@ -0,0 +1,59 @@
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is AddonManager XPCOM wrapper.
+ *
+ * The Initial Developer of the Original Code is
+ * Mook <marky+mozhg@activestate.com>.
+ * Portions created by the Initial Developer are Copyright (C) 2011
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#include "nsISupports.idl"
+
+/* XPCOM wrapper for AddonManager AddonListener
+ * @see https://developer.mozilla.org/en/Addons/Add-on_Manager/AddonListener
+ */
+
+interface amIAddon;
+
+[scriptable, uuid(7de011eb-ac24-4196-9c9c-3935fa0ef7c9)]
+interface amIAddonListener: nsISupports {
+    void onEnabling(in amIAddon addon, in boolean needsRestart);
+    void onEnabled(in amIAddon addon);
+    void onDisabling(in amIAddon addon, in boolean needsRestart);
+    void onDisabled(in amIAddon addon);
+    void onInstalling(in amIAddon addon, in boolean needsRestart);
+    void onInstalled(in amIAddon addon);
+    void onUninstalling(in amIAddon addon, in boolean needsRestart);
+    void onUninstalled(in amIAddon addon);
+    void onOperationCancelled(in amIAddon addon);
+    void onPropertyChanged(in amIAddon addon,
+                           [array, size_is(propertyCount)] in string properties,
+                           [optional] in unsigned long propertyCount);
+};
diff --git a/toolkit/mozapps/extensions/xpcom/amIAddonManager.idl b/toolkit/mozapps/extensions/xpcom/amIAddonManager.idl
new file mode 100644
--- /dev/null
+++ b/toolkit/mozapps/extensions/xpcom/amIAddonManager.idl
@@ -0,0 +1,191 @@
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is AddonManager XPCOM wrapper.
+ *
+ * The Initial Developer of the Original Code is
+ * Mook <marky+mozhg@activestate.com>.
+ * Portions created by the Initial Developer are Copyright (C) 2011
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#include "nsISupports.idl"
+
+/* XPCOM wrapper for AddonManager.jsm
+ * @see resource://gre/modules/AddonManager.jsm
+ * @see https://developer.mozilla.org/en/Addons/Add-on_Manager/AddonManager
+ */
+
+interface amIAddonCallback;
+interface amIAddonListCallback;
+interface amIInstallCallback;
+interface amIInstallListCallback;
+
+interface amIAddon;
+interface amIAddonInstall;
+interface amIAddonListener;
+interface amIInstallListener;
+
+interface nsIDOMWindow;
+interface nsIFile;
+interface nsILoadGroup;
+interface nsIURI;
+
+[scriptable, uuid(40356a2f-c12e-4f71-b4f4-0b761d84b110)]
+interface amIAddonManager: nsISupports {
+    void getInstallForURL(in AUTF8String url,
+                          in amIInstallCallback callback,
+                          in ACString mimetype,
+                          [optional] in ACString hash,
+                          [optional] in AString name,
+                          [optional] in ACString iconURL,
+                          [optional] in AUTF8String version,
+                          [optional] in nsILoadGroup loadGroup);
+
+    void getInstallForFile(in nsIFile file,
+                           in amIInstallCallback callback,
+                           [optional] in ACString mimetype);
+
+    void getAllInstalls(in amIInstallListCallback callback);
+
+    void getInstallsByTypes([array, size_is(typeCount)] in string types,
+                            in amIInstallListCallback callback,
+                            in unsigned long typeCount);
+
+    void installAddonsFromWebpage(in ACString mimetype,
+                                  in nsIDOMWindow source,
+                                  in nsIURI uri,
+                                  [array, size_is(installCount)] in amIAddonInstall installs,
+                                  in unsigned long installCount);
+
+    void addInstallListener(in amIInstallListener listener);
+
+    void removeInstallListener(in amIInstallListener listener);
+
+    void getAllAddons(in amIAddonListCallback callback);
+
+    void getAddonByID(in AUTF8String id,
+                      in amIAddonCallback callback);
+
+    void getAddonsByIDs([array, size_is(idCount)] in wstring ids,
+                        in amIAddonListCallback callback,
+                        in unsigned long idCount);
+
+    void getAddonsByTypes([array, size_is(typeCount)] in string types,
+                          in amIAddonListCallback callback,
+                          in unsigned long typeCount);
+
+    void getAddonsWithOperationsByTypes([array, size_is(typeCount)] in string types,
+                                        in amIAddonListCallback callback,
+                                        in unsigned long typeCount);
+
+    void addAddonListener(in amIAddonListener listener);
+
+    void removeAddonListener(in amIAddonListener listener);
+
+    // mystery undocumented method!
+    boolean isInstallAllowed(in ACString mimetype,
+                             in nsIURI uri);
+    boolean isInstallEnabled(in ACString mimetype);
+
+    const long STATE_AVAILABLE       = 0;
+    const long STATE_DOWNLOADING     = 1;
+    const long STATE_CHECKING        = 2;
+    const long STATE_DOWNLOADED      = 3;
+    const long STATE_DOWNLOAD_FAILED = 4;
+    const long STATE_INSTALLING      = 5;
+    const long STATE_INSTALLED       = 6;
+    const long STATE_INSTALL_FAILED  = 7;
+    const long STATE_CANCELLED       = 8;
+
+    const long ERROR_NETWORK_FAILURE = -1;
+    const long ERROR_INCORRECT_HASH  = -2;
+    const long ERROR_CORRUPT_FILE    = -3;
+    const long ERROR_FILE_ACCESS     = -4;
+    
+    const long UPDATE_WHEN_USER_REQUESTED    = 1;
+    const long UPDATE_WHEN_NEW_APP_DETECTED  = 2;
+    const long UPDATE_WHEN_NEW_APP_INSTALLED = 3;
+    const long UPDATE_WHEN_PERIODIC_UPDATE   = 16;
+    const long UPDATE_WHEN_ADDON_INSTALLED   = 17;
+
+    const long AUTOUPDATE_DISABLE = 0;
+    const long AUTOUPDATE_DEFAULT = 1;
+    const long AUTOUPDATE_ENABLE  = 2;
+
+    const long PENDING_NONE      = 0;
+    const long PENDING_ENABLE    = 1;
+    const long PENDING_DISABLE   = 2;
+    const long PENDING_UNINSTALL = 4;
+    const long PENDING_INSTALL   = 8;
+    const long PENDING_UPGRADE   = 16;
+
+    const long PERM_CAN_UNINSTALL = 1;
+    const long PERM_CAN_ENABLE    = 2;
+    const long PERM_CAN_DISABLE   = 4;
+    const long PERM_CAN_UPGRADE   = 8;
+
+    const long OP_NEEDS_RESTART_NONE      = 0;
+    const long OP_NEEDS_RESTART_ENABLE    = 1;
+    const long OP_NEEDS_RESTART_DISABLE   = 2;
+    const long OP_NEEDS_RESTART_UNINSTALL = 4;
+    const long OP_NEEDS_RESTART_INSTALL   = 8;
+
+    const long SCOPE_PROFILE     = 1;
+    const long SCOPE_USER        = 2;
+    const long SCOPE_APPLICATION = 4;
+    const long SCOPE_SYSTEM      = 8;
+    const long SCOPE_ALL         = 15;
+
+    // undocumented constants
+    const long UPDATE_STATUS_NO_ERROR       =  0;
+    const long UPDATE_STATUS_TIMEOUT        = -1;
+    const long UPDATE_STATUS_DOWNLOAD_ERROR = -2;
+    const long UPDATE_STATUS_PARSE_ERROR    = -3;
+    const long UPDATE_STATUS_UNKNOWN_FORMAT = -4;
+    const long UPDATE_STATUS_SECURITY_ERROR = -5;
+};
+
+[scriptable, function, uuid(9a3c8c2e-e3a2-47b1-a8d8-0abd5963c28c)]
+interface amIAddonCallback: nsISupports {
+    void AddonCallback(in amIAddon addon);
+};
+[scriptable, function, uuid(c6afa05c-2682-4fa3-9f23-3ce6867b0e18)]
+interface amIAddonListCallback: nsISupports {
+    void AddonListCallback([array, size_is(addonCount)] in amIAddon addons,
+                           [optional] in unsigned long addonCount);
+};
+[scriptable, function, uuid(f985d564-33d0-4d2e-8a2e-35de506e2694)]
+interface amIInstallCallback: nsISupports {
+    void InstallCallback(in amIAddonInstall install);
+};
+[scriptable, function, uuid(a3d8236a-5cd4-4561-875f-8e2a9896ad01)]
+interface amIInstallListCallback: nsISupports {
+    void InstallListCallback([array, size_is(installCount)] in amIAddonInstall installs,
+                             [optional] in unsigned long installCount);
+};
diff --git a/toolkit/mozapps/extensions/xpcom/amIInstallListener.idl b/toolkit/mozapps/extensions/xpcom/amIInstallListener.idl
new file mode 100644
--- /dev/null
+++ b/toolkit/mozapps/extensions/xpcom/amIInstallListener.idl
@@ -0,0 +1,62 @@
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is AddonManager XPCOM wrapper.
+ *
+ * The Initial Developer of the Original Code is
+ * Mook <marky+mozhg@activestate.com>.
+ * Portions created by the Initial Developer are Copyright (C) 2011
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#include "nsISupports.idl"
+
+/* XPCOM wrapper for AddonManager InstallListener
+ * @see https://developer.mozilla.org/en/Addons/Add-on_Manager/InstallListener
+ */
+
+interface amIAddon;
+interface amIAddonInstall;
+
+[scriptable, uuid(51401eb3-14f5-4c32-b713-ea308b844b2b)]
+interface amIInstallListener: nsISupports {
+    boolean onNewInstall(in amIAddonInstall install);
+    boolean onDownloadStarted(in amIAddonInstall install);
+    boolean onDownloadProgress(in amIAddonInstall install);
+    boolean onDownloadEnded(in amIAddonInstall install);
+    boolean onDownloadCancelled(in amIAddonInstall install);
+    boolean onDownloadFailed(in amIAddonInstall install);
+    boolean onInstallStarted(in amIAddonInstall install);
+    boolean onInstallEnded(in amIAddonInstall install,
+                           in amIAddon addon);
+    boolean onInstallCancelled(in amIAddonInstall install);
+    boolean onInstallFailed(in amIAddonInstall install);
+    boolean onExternalInstall(in amIAddon addon,
+                           in amIAddon existingAddon,
+                           in boolean needsRestart);
+};
diff --git a/toolkit/mozapps/extensions/xpcom/amIUpdateListener.idl b/toolkit/mozapps/extensions/xpcom/amIUpdateListener.idl
new file mode 100644
--- /dev/null
+++ b/toolkit/mozapps/extensions/xpcom/amIUpdateListener.idl
@@ -0,0 +1,59 @@
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is AddonManager XPCOM wrapper.
+ *
+ * The Initial Developer of the Original Code is
+ * Mook <marky+mozhg@activestate.com>.
+ * Portions created by the Initial Developer are Copyright (C) 2011
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#include "nsISupports.idl"
+
+/* XPCOM wrapper for AddonManager UpdateListener
+ * @see https://developer.mozilla.org/en/Addons/Add-on_Manager/UpdateListener
+ */
+
+interface amIAddon;
+interface amIAddonInstall;
+
+[scriptable, uuid(2c3a0cc4-cf95-48e3-98e9-3f459a22bd97)]
+interface amIUpdateListener: nsISupports {
+    void onCompatibilityUpdateAvailable(in amIAddon addon);
+    void onNoCompatibilityUpdateAvailable(in amIAddon addon);
+    void onUpdateAvailable(in amIAddon addon, in amIAddonInstall install);
+    void onNoUpdateAvailable(in amIAddon addon);
+    void onUpdateFinished(in amIAddon addon, in long error);
+    
+    /**
+     * Check whether we should have the given method (since you can't have
+     * interfaces with half the methods)
+     */
+    boolean hasMethod(in ACString methodName);
+};
